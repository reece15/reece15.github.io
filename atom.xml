<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>除了代码也想写点其他的</title>
  <icon>https://www.gravatar.com/avatar/06aec78c003bcdbb5452f0d1a98f2b77</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.javabin.cn/"/>
  <updated>2024-03-11T17:10:40.233Z</updated>
  <id>http://www.javabin.cn/</id>
  
  <author>
    <name>reece</name>
    <email>reece@javabin.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【AirTag】为低功耗蓝牙设备添加AirTag功能</title>
    <link href="http://www.javabin.cn/2024/airtag.html"/>
    <id>http://www.javabin.cn/2024/airtag.html</id>
    <published>2024-03-07T14:12:23.000Z</published>
    <updated>2024-03-11T17:10:40.233Z</updated>
    
    <content type="html"><![CDATA[<p>最近想买个自行车，在网上看了些攻略后发现自行车有个缺点就是容易丢，必须人不离车，在我看来这样反而非常麻烦，完全没有了骑行的乐趣。</p><p>随后又在b站上看到有给车装定位装置的，但是一般的车用定位器有两个缺点：1. 非常大，非常明显，很容易被发现然后被拆掉；2.非常耗电，自身待机只有一周，一个每周都要充电的智能设备在我看来是非常不智能的。</p><p>最终发现只有AirTag非常适合，体积小，只有硬币大小，可以直接塞到不起眼的地方；再一个功耗很低，可以待机1年多。但是AirTag只支持ios系统，且必须是iphone12以上才行，如果用为了定位还得再带一部手机，那更难受了。</p><p>虽然麻烦，但还是买了两个AirTag打算测试一下，在等AirTag送货的期间，查了下资料发现完全可以自己改造一个AirTag， 并且在安卓手机上获取位置信息。</p><p>所以这篇blog主要记录如何为低功耗蓝牙设备添加AirTag功能，且从安卓手机端获取定位记录。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>目录</li><li>需要准备<ul><li>硬件</li><li>软件</li></ul></li><li>步骤<ul><li>部署服务端项目</li><li>安装手机端</li><li>生成advertisement key</li><li>修改固件</li><li>编译</li></ul></li><li>FindMy网络<ul><li>原理</li><li>蓝牙协议</li></ul></li></ul><a id="more"></a><h2 id="需要准备"><a href="#需要准备" class="headerlink" title="需要准备"></a>需要准备</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>硬件由于我手头只有TLSR8359芯片的墨水屏电子价签，所以只需要TLSR8359芯片的墨水屏电子价签即可。墨水屏芯片本身耗电特别低，在显示静态图片的情况下，可以待机一到两年。</p><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul><li>墨水屏固件项目 <a href="https://github.com/reece15/stellar-L3N-etag" target="_blank" rel="noopener">https://github.com/reece15/stellar-L3N-etag</a>  (该项目对固件代码进行了修改，已经添加了对AirTag协议的支持，其他低功耗蓝牙设备固件也可进行类似的操作)</li><li>服务端/手机端项目 <a href="https://github.com/dchristl/macless-haystack" target="_blank" rel="noopener">https://github.com/dchristl/macless-haystack</a> </li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="部署服务端项目"><a href="#部署服务端项目" class="headerlink" title="部署服务端项目"></a>部署服务端项目</h3><p>参考该项目 <a href="https://github.com/dchristl/macless-haystack" target="_blank" rel="noopener">https://github.com/dchristl/macless-haystack</a> ， 使用docker将anisette-v3，macless-haystack部署到服务器。（在这之前你需要在 <a href="https://appleid.apple.com/" target="_blank" rel="noopener">https://appleid.apple.com/</a> 上注册一个新的apple id, 注意：不建议使用你自己正在使用的apple id）</p><h3 id="安装手机端"><a href="#安装手机端" class="headerlink" title="安装手机端"></a>安装手机端</h3><ul><li>在 <a href="https://github.com/dchristl/macless-haystack/releases" target="_blank" rel="noopener">https://github.com/dchristl/macless-haystack/releases</a> 下载适合自己手机的apk安装到手机</li><li>在 app的设置中配置自己的服务端地址，一般为 <a href="http://{你的服务器地址}:6176" target="_blank" rel="noopener">http://{你的服务器地址}:6176</a></li></ul><h3 id="生成advertisement-key"><a href="#生成advertisement-key" class="headerlink" title="生成advertisement key"></a>生成advertisement key</h3><ul><li>在app中创建accessories，导出advertisement key(base64)</li><li>在安装有python的linux/windows服务器上执行 <code>python3 -c &#39;import base64; print(&quot;,&quot;.join(hex(i) for i in base64.b64decode(&quot;你导出的advertisement key&quot;)))&#39;</code>获取到输出的advertisement key数组</li></ul><h3 id="修改固件"><a href="#修改固件" class="headerlink" title="修改固件"></a>修改固件</h3><ul><li>将 <a href="https://github.com/reece15/stellar-L3N-etag" target="_blank" rel="noopener">https://github.com/reece15/stellar-L3N-etag</a> 项目同步到本地</li><li>使用python脚本输出的advertisement key数组替换掉 stellar-L3N-etag 项目Firmware/src/ble.c 文件中 PUB_KEY数组内的数据</li><li>将stellar-L3N-etag 项目 Firmware/src/ble.c 中 AIR_TAG_OPEN 的值改为 1</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><ul><li>进入 stellar-L3N-etag 项目Firmware目录，执行<code>makeit.exe clean &amp;&amp; makeit.exe -j12</code></li><li>将生成的固件刷入设备即可（具体可参考stellar-L3N-etag readme）</li></ul><h1 id="FindMy网络"><a href="#FindMy网络" class="headerlink" title="FindMy网络"></a>FindMy网络</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>苹果手机默认会打开蓝牙，作为FindMy网络中的无数个客户端</li><li>AirTag设备默认会广播自己内置的advertisement key， 当附近的苹果设备接受到这个广播信息时，就会使用收到的advertisement key（公钥）加密自己的位置信息，然后上传到apple服务器。详细代码可参考: <a href="https://github.com/reece15/stellar-L3N-etag/blob/e04181b22c15b4094523f18e8099bea0c33368d3/Firmware/src/ble.c#L218" target="_blank" rel="noopener">https://github.com/reece15/stellar-L3N-etag/blob/e04181b22c15b4094523f18e8099bea0c33368d3/Firmware/src/ble.c#L218</a>  以及 <a href="https://github.com/reece15/stellar-L3N-etag/blob/e04181b22c15b4094523f18e8099bea0c33368d3/Firmware/src/ble.c#L128" target="_blank" rel="noopener">https://github.com/reece15/stellar-L3N-etag/blob/e04181b22c15b4094523f18e8099bea0c33368d3/Firmware/src/ble.c#L128</a></li><li>advertisement key的生成者可使用<code>hash(advertisement key)</code>从苹果服务器查询加密的位置信息列表，然后使用私钥解密出真实的位置信息。详细代码可参考: <a href="https://github.com/biemster/FindMy/blob/113ebf4017729b92a381624c1932065588c3ebde/request_reports.py#L71" target="_blank" rel="noopener">https://github.com/biemster/FindMy/blob/113ebf4017729b92a381624c1932065588c3ebde/request_reports.py#L71</a><br><img src="/photo_2024/findmy_network.png" alt=""></li></ul><h2 id="蓝牙协议"><a href="#蓝牙协议" class="headerlink" title="蓝牙协议"></a>蓝牙协议</h2><ul><li>低功耗蓝牙设备需要将自己的MAC地址设置为advertisement key的一部分，且通过发送长度为30的广播包来传输advertisement key的另一部分</li><li>具体协议说明以PUB_KEY=0x49,0x88,0x0,0x7a,0x27,0xac,0x38,0xb7,0x16,0x55,0x3c,0xc8,0x57,0x62,0x93,0xc3,0x95,0xef,0x3f,0x63,0x70,0xb2,0xa3,0x96,0x6d,0x4c,0x1a,0x7d 举例：</li><li>蓝牙设备MAC 地址</li></ul><table><thead><tr><th>index</th><th>值 (举例)</th><th>备注</th></tr></thead><tbody><tr><td>0</td><td>0xc9</td><td>advertisement key的0位的低6位</td></tr><tr><td>1</td><td>0x88007A27AC</td><td>advertisement key的1-5位</td></tr></tbody></table><ul><li>广播协议</li></ul><table><thead><tr><th>index</th><th>值  (举例)</th><th>备注</th></tr></thead><tbody><tr><td>0</td><td>0x1e</td><td>总长度  （固定）</td></tr><tr><td>1</td><td>0xff</td><td>厂商自定义格式</td></tr><tr><td>2-3</td><td>0x4c00</td><td>苹果公司ID</td></tr><tr><td>4</td><td>0x12</td><td>设备类型</td></tr><tr><td>5</td><td>0x19</td><td>数据长度</td></tr><tr><td>6</td><td>0x00</td><td>状态信息</td></tr><tr><td>7-29</td><td>0x38B716553CC8576293C3953F3F6370B2A3966D4C1A</td><td>advertisement key的6-28位</td></tr><tr><td>30</td><td>0x01</td><td>advertisement key的0位的高2位</td></tr><tr><td>31</td><td>0x00</td><td>计数</td></tr></tbody></table><h2 id="资料、参考"><a href="#资料、参考" class="headerlink" title="资料、参考"></a>资料、参考</h2><blockquote><p>github项目（支持安卓端查询定位数据） <a href="https://github.com/dchristl/macless-haystack" target="_blank" rel="noopener">https://github.com/dchristl/macless-haystack</a><br>github项目（支持MAC端查询定位数据） <a href="https://github.com/malmeloo/openhaystack" target="_blank" rel="noopener">https://github.com/malmeloo/openhaystack</a><br>AirTag协议 <a href="https://support.apple.com/en-gb/guide/security/sece994d0126/web" target="_blank" rel="noopener">https://support.apple.com/en-gb/guide/security/sece994d0126/web</a><br>原理 <a href="https://arxiv.org/pdf/2103.02282.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/2103.02282.pdf</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想买个自行车，在网上看了些攻略后发现自行车有个缺点就是容易丢，必须人不离车，在我看来这样反而非常麻烦，完全没有了骑行的乐趣。&lt;/p&gt;
&lt;p&gt;随后又在b站上看到有给车装定位装置的，但是一般的车用定位器有两个缺点：1. 非常大，非常明显，很容易被发现然后被拆掉；2.非常耗电，自身待机只有一周，一个每周都要充电的智能设备在我看来是非常不智能的。&lt;/p&gt;
&lt;p&gt;最终发现只有AirTag非常适合，体积小，只有硬币大小，可以直接塞到不起眼的地方；再一个功耗很低，可以待机1年多。但是AirTag只支持ios系统，且必须是iphone12以上才行，如果用为了定位还得再带一部手机，那更难受了。&lt;/p&gt;
&lt;p&gt;虽然麻烦，但还是买了两个AirTag打算测试一下，在等AirTag送货的期间，查了下资料发现完全可以自己改造一个AirTag， 并且在安卓手机上获取位置信息。&lt;/p&gt;
&lt;p&gt;所以这篇blog主要记录如何为低功耗蓝牙设备添加AirTag功能，且从安卓手机端获取定位记录。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;需要准备&lt;ul&gt;
&lt;li&gt;硬件&lt;/li&gt;
&lt;li&gt;软件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;步骤&lt;ul&gt;
&lt;li&gt;部署服务端项目&lt;/li&gt;
&lt;li&gt;安装手机端&lt;/li&gt;
&lt;li&gt;生成advertisement key&lt;/li&gt;
&lt;li&gt;修改固件&lt;/li&gt;
&lt;li&gt;编译&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FindMy网络&lt;ul&gt;
&lt;li&gt;原理&lt;/li&gt;
&lt;li&gt;蓝牙协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="固件" scheme="http://www.javabin.cn/tags/%E5%9B%BA%E4%BB%B6/"/>
    
      <category term="墨水屏" scheme="http://www.javabin.cn/tags/%E5%A2%A8%E6%B0%B4%E5%B1%8F/"/>
    
      <category term="AirTag" scheme="http://www.javabin.cn/tags/AirTag/"/>
    
  </entry>
  
  <entry>
    <title>postgresql迁移到lightdb[安装lightdb+postgis环境以及兼容性测试]</title>
    <link href="http://www.javabin.cn/2023/lightdb_postgis.html"/>
    <id>http://www.javabin.cn/2023/lightdb_postgis.html</id>
    <published>2023-09-21T12:47:24.000Z</published>
    <updated>2024-03-11T14:49:03.605Z</updated>
    
    <content type="html"><![CDATA[<p>打算将<code>postgresql</code>数据库迁移到国产数据库<code>lightdb</code>，测试后发现官方提供的<code>lightdb-X</code>最新版存在一些问题，而<code>23.1</code>版本只需要做很小的调整就可以将基于postgresql的后端代码迁移到lightdb。以下内容使用版本为 <code>lightdb-X</code>的<code>23.1</code>版本，<code>centos7 x64</code>系统。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>目录</li><li>postgresql迁移到lightdb-x-23.1版本需要调整</li><li>安装lightdb</li><li>编译安装postgis</li><li>遇到的问题</li></ul><a id="more"></a><h2 id="postgresql迁移到lightdb-x-23-1版本需要调整"><a href="#postgresql迁移到lightdb-x-23-1版本需要调整" class="headerlink" title="postgresql迁移到lightdb-x-23.1版本需要调整"></a>postgresql迁移到lightdb-x-23.1版本需要调整</h2><ul><li>由于插件<code>pg_trgm</code>名称修改为<code>lt_trgm</code>, 所以需要将<code>pg_trgm</code>插件创建相关代码需要调整为<code>lt_trgm</code></li><li>由于<code>sqlalchemy</code> 在pg方言实现中，校验了<code>pg server</code>版本名称，而ligthdb版本号不符合格式要求，需要修改下sqlalchemy源码来跳过检查</li><li>需要编译安装postgis插件</li><li>官方未提供docker部署方式</li><li>如果切换到lightdb-x最新版，还有一些兼容性问题需要解决</li></ul><h2 id="安装lightdb"><a href="#安装lightdb" class="headerlink" title="安装lightdb"></a>安装lightdb</h2><h3 id="安装基础工具和官方文档未提及的库"><a href="#安装基础工具和官方文档未提及的库" class="headerlink" title="安装基础工具和官方文档未提及的库"></a>安装基础工具和官方文档未提及的库</h3><pre><code class="shell">    yum install unzip wget bzip2 epel-release.noarch -y    yum groupinstall &quot;Development Tools&quot;    yum install curl-devel libzstd.x86_64 libxml2-devel.x86_64 -y</code></pre><h3 id="安装ligthdb依赖-（同官方文档一致）"><a href="#安装ligthdb依赖-（同官方文档一致）" class="headerlink" title="安装ligthdb依赖 （同官方文档一致）"></a>安装ligthdb依赖 （同<a href="http://www.light-pg.com/docs/LightDB_Install_Manual/current/index.html" target="_blank" rel="noopener">官方文档</a>一致）</h3><pre><code class="shell">    # 1.下载数据库安装包    cd /opt/    mkdir lightdb    cd lightdb/    wget https://www.hs.net/lightdb/download/lightdb-x-13.8-23.1-10555-el7.x86_64.zip    unzip lightdb-x-13.8-23.1-10555-el7.x86_64.zip    cd lightdb-x-13.8-23.1-10555-el7.x86_64    # 2.设置防火墙    iptables -A INPUT -p tcp --dport 5432 -j ACCEPT    iptables -A INPUT -p udp --dport 123 -j ACCEPT    firewall-cmd --permanent --add-port=123/udp    firewall-cmd --permanent --add-port=5432/tcp    # 2.或者关闭防火墙    systemctl stop firewalld.service    systemctl disable firewalld.service    systemctl stop NetworkManager.service    systemctl disable NetworkManager.service    # 3.关闭selinux    sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config    setenforce 0    # 4.设置时区    timedatectl set-timezone Asia/Shanghai    # 5.安装依赖    yum install -y procps-ng    yum install -y coreutils    # 数据库的运行依赖    yum install -y readline    yum install -y zlib    yum install -y libxml2    yum install -y openssl-libs    yum install -y uuid    yum install -y c-ares libpcap snappy # tshark    yum install -y ncurses-libs # iftop    yum install -y libnl3 # keepalived ipv6    yum install -y libzstd # canopy    yum install -y sysstat    yum install -y json-c    yum install -y libicu    yum install -y bc    # 6.添加lightdb用户    groupadd lightdb    useradd -g lightdb -m lightdb    passwd lightdb    mkdir -p /usr/local/lightdb    chown -R lightdb:lightdb /usr/local/lightdb    mkdir -p /data/lightdb_data    chown -R lightdb:lightdb /data/lightdb_data    chown -R lightdb:lightdb /opt/lightdb    tee -a /etc/sudoers &lt;&lt;&lt; &quot;lightdb ALL=(ALL)       NOPASSWD:ALL&quot;    # 7.设置内核参数    echo &quot;kernel.shmmni=4096&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;kernel.shmmax=$(expr $(getconf _PHYS_PAGES) / 2 \* $(getconf PAGE_SIZE))&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;kernel.shmall=$(expr $(getconf _PHYS_PAGES) / 2)&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;kernel.sem=500 2048000 200 4096&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;fs.aio-max-nr=1048576&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;fs.file-max=524288&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;vm.swappiness=5&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;vm.overcommit_memory=2&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;vm.overcommit_ratio=75&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;vm.dirty_background_ratio=5&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;vm.dirty_ratio=40&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;vm.dirty_expire_centisecs=500&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;vm.dirty_writeback_centisecs=250&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;net.core.somaxconn=2000&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;net.ipv4.tcp_max_syn_backlog=2000&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;net.ipv4.tcp_tw_reuse=1&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;net.ipv4.tcp_syn_retries=3&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;net.ipv4.tcp_retries2=5&quot; &gt;&gt; /etc/sysctl.conf    echo &quot;net.ipv4.tcp_slow_start_after_idle=0&quot; &gt;&gt; /etc/sysctl.conf    sysctl -p    echo &quot;lightdb hard core   unlimited&quot; &gt;&gt; /etc/security/limits.conf    echo &quot;lightdb soft core   unlimited&quot; &gt;&gt; /etc/security/limits.conf    echo &quot;lightdb hard nofile 524288&quot;    &gt;&gt; /etc/security/limits.conf    echo &quot;lightdb soft nofile 524288&quot;    &gt;&gt; /etc/security/limits.conf    echo &quot;lightdb hard nproc  16384&quot;     &gt;&gt; /etc/security/limits.conf    echo &quot;lightdb soft nproc  16384&quot;     &gt;&gt; /etc/security/limits.conf    # 然后su - lightdb切换到lightdb用户使设置生效，运行ulimit -c、ulimit -n和ulimit -u命令确认设置生效。    # 8.设置Swap交换区大小    dd if=/dev/zero of=/swap bs=1M count=2048    mkswap -f /swap    chmod 0600 /swap    swapon /swap    tee -a /etc/fstab &lt;&lt;&lt; &quot;/swap swap swap defaults 0 0&quot;</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行<code>./install.sh</code>后按<a href="http://www.light-pg.com/docs/LightDB_Install_Manual/current/install.html#id13" target="_blank" rel="noopener">官方文档</a>给出的说明，进行选择。</p><h3 id="启动一个数据库实例"><a href="#启动一个数据库实例" class="headerlink" title="启动一个数据库实例"></a>启动一个数据库实例</h3><pre><code class="shell">    su - ligthdb    nohup /usr/local/lightdb/lightdb-x/13.8-23.1/bin/lightdb -D /data/lightdb_data &amp;</code></pre><h3 id="检查数据库是否安装正常"><a href="#检查数据库是否安装正常" class="headerlink" title="检查数据库是否安装正常"></a>检查数据库是否安装正常</h3><p>链接数据库并查看数据库版本号。</p><pre><code class="shell">    ltsql -p 5432 -hlocalhost -c &#39;select version();&#39;</code></pre><h2 id="编译安装postgis"><a href="#编译安装postgis" class="headerlink" title="编译安装postgis"></a>编译安装postgis</h2><p>postgis需要手动编译安装postgis以及依赖的geos、sqlite3、proj。版本：<code>geos-3.10.2, sqlite3-3.43.1, proj-8.2.1, postgis-3.4.0, lighdb-x-23.1</code></p><h3 id="安装依赖geos"><a href="#安装依赖geos" class="headerlink" title="安装依赖geos"></a>安装依赖geos</h3><pre><code class="shell">    cd /opt/lightdb/    wget http://download.osgeo.org/geos/geos-3.10.2.tar.bz2    tar -xjvf geos-3.10.2.tar.bz2    cd geos-3.10.2    cmake3 .    make    make install    # 检查是否正常安装    geos-config --version</code></pre><h3 id="安装依赖sqlite3"><a href="#安装依赖sqlite3" class="headerlink" title="安装依赖sqlite3"></a>安装依赖sqlite3</h3><pre><code class="shell">    curl -k -O https://www.sqlite.org/2023/sqlite-autoconf-3430100.tar.gz    tar xzf sqlite-autoconf-3430100.tar.gz    cd sqlite-autoconf-3430100    ./configure    make    make install    # 检查是否正常安装    sqlite3 --version    # 设置pkgconfig路径（编译proj和postgis时会用到）    export PKG_CONFIG_PATH=/usr/lib64/pkgconfig:/usr/share/pkgconfig:/usr/local/lib/pkgconfig:/usr/local/lib64/pkgconfig:/usr/local/lightdb/lightdb-x/13.8-23.1/lib/pkgconfig:/usr/local/lightdb/lightdb-x/13.8-23.1/tools/lib64/pkgconfig:/opt/lightdb/lightdb-x-13.8-23.1-10555-el7.x86_64/lightdb-x/13.8-23.1/lib/pkgconfig:/opt/lightdb/lightdb-x-13.8-23.1-10555-el7.x86_64/lightdb-x/13.8-23.1/tools/lib64/pkgconfig</code></pre><h3 id="安装依赖proj"><a href="#安装依赖proj" class="headerlink" title="安装依赖proj"></a>安装依赖proj</h3><pre><code class="shell">    yum install libtiff-devel.x86_64    wget https://download.osgeo.org/proj/proj-8.2.1.tar.gz    tar zxf proj-8.2.1.tar.gz    cd proj-8.2.1    ./configure    make    make install    # 检查是否正常安装    proj</code></pre><h3 id="安装postgis"><a href="#安装postgis" class="headerlink" title="安装postgis"></a>安装postgis</h3><pre><code class="shell">    wget https://download.osgeo.org/postgis/source/postgis-3.4.0.tar.gz    tar xzf postgis-3.4.0.tar.gz    cd postgis-3.4.0    # 配置并指定lt_config位置    ./configure --without-json --without-protobuf --without-raster --without-topology --with-pgconfig=/usr/local/lightdb/lightdb-x/13.8-23.1/bin/lt_config    make -j8    make install    # 设置静态库路径    su - lightdb    tee -a ~/.bashrc &lt;&lt;&lt; &quot;export LD_LIBRARY_PATH=/usr/local/lib64:/usr/lib64:/usr/local/lib/:/usr/lib/:/usr/local/lightdb/lightdb-x/13.8-23.1/lib/3rd:/usr/local/lightdb/lightdb-x/13.8-23.1/lib:/usr/local/lightdb/lightdb-x/13.8-23.1/lib/ltext:/usr/local/lightdb/lightdb-x/13.8-23.1/tools/lib64:$LD_LIBRARY_PATH&quot;</code></pre><h3 id="检查postgis是否正常安装"><a href="#检查postgis是否正常安装" class="headerlink" title="检查postgis是否正常安装"></a>检查postgis是否正常安装</h3><pre><code class="shell">    ltsql -p 5432 -hlocalhost    CREATE EXTENSION postgis;    SELECT postgis_full_version();</code></pre><h2 id="迁移遇到的问题"><a href="#迁移遇到的问题" class="headerlink" title="迁移遇到的问题"></a>迁移遇到的问题</h2><ul><li>Q: 从<code>postgresql</code>迁移到<code>lightdb</code>,应该使用哪个版本?<ul><li>A: 在<code>centos7 x64</code>系统下测试了最新版的<code>lightdb-X</code>， 最新版<code>lightdb-A</code>以及<code>23.1</code>版本<code>lightdb-x</code>数据库，目前看<code>23.1</code>版本的<code>ligthdb-x</code>数据库可以在代码改动非常小的情况下迁移到ligthdb。</li></ul></li><li>Q: 安装<code>proj</code>时报错<code>sqlite3</code>找不到,但是<code>sqlite3</code>已经正常安装<ul><li>A: 未正确设置<code>PKG_CONFIG_PATH</code>, 解决：执行<code>find / -name &quot;pkgconfig&quot; -print</code>查找相关<code>pkgconfig</code>路径，设置到环境变量<code>PKG_CONFIG_PATH</code>, </li></ul></li><li>Q: <code>postgis</code>安装成功后，查询时报错<code>libgeos, libpq.so.5</code>等so文件不存在<ul><li>A: 执行 <code>find /usr/ -name *libgeos*</code>和<code>find /usr/ -name *ibpq.so*</code>将相关路径加入环境变量<code>LD_LIBRARY_PATH</code>，然后重启数据库</li></ul></li><li>Q: <code>sqlalchemy</code>库报错。<ul><li>A: <code>sqlalchemy</code> 在pg方言实现中，校验了<code>pg server</code>版本名称，而版本号<code>LightDB 13.8-23.1 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44), 64-bit</code>不符合正则表达式要求。 解决：需要<code>patch</code>下<code>sqlalchemy</code>源码，跳过检查即可。</li></ul></li><li>Q: <code>pg_trgm</code>插件报错。<ul><li>A: 名称变更为<code>lt_trgm</code>。解决：调整名称和相关的代码。</li></ul></li><li>Q:<code>level</code>相关字段似乎和内置字段名称冲突（lightdb-X最新版）<ul><li>A：在使用lightdb最新版(<code>LightDB1.0-x-V202302-00-000-el7-x86_64</code>)时，以前库里的<code>level</code>相关字段无法正常工作，似乎会和内置字段名称冲突。解决：需要修改migration语句，为相关字段添加反引号</li></ul></li><li>Q: <code>btree_gist</code>插件未提供。 (<code>lightdb-A</code>最新版) <ul><li>A: 需提供<code>btree_gist</code>插件</li></ul></li><li>Q:<code>log</code>相关字段似乎和内置字段名称冲突（<code>lightdb-A</code>最新版）<ul><li>A：在使用<code>lightdb</code>最新版(<code>lightdb</code>提供的<code>lightdb-A</code>类型数据库)时，以前库里的<code>level</code>相关字段无法正常工作，似乎会和内置字段名称冲突。解决：需要修改migration语句，为相关字段添加反引号</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打算将&lt;code&gt;postgresql&lt;/code&gt;数据库迁移到国产数据库&lt;code&gt;lightdb&lt;/code&gt;，测试后发现官方提供的&lt;code&gt;lightdb-X&lt;/code&gt;最新版存在一些问题，而&lt;code&gt;23.1&lt;/code&gt;版本只需要做很小的调整就可以将基于postgresql的后端代码迁移到lightdb。以下内容使用版本为 &lt;code&gt;lightdb-X&lt;/code&gt;的&lt;code&gt;23.1&lt;/code&gt;版本，&lt;code&gt;centos7 x64&lt;/code&gt;系统。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;postgresql迁移到lightdb-x-23.1版本需要调整&lt;/li&gt;
&lt;li&gt;安装lightdb&lt;/li&gt;
&lt;li&gt;编译安装postgis&lt;/li&gt;
&lt;li&gt;遇到的问题&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="postgresql" scheme="http://www.javabin.cn/tags/postgresql/"/>
    
      <category term="运维" scheme="http://www.javabin.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="信创" scheme="http://www.javabin.cn/tags/%E4%BF%A1%E5%88%9B/"/>
    
      <category term="lightdb" scheme="http://www.javabin.cn/tags/lightdb/"/>
    
      <category term="数据库迁移" scheme="http://www.javabin.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>Milvus 数据迁移和备份</title>
    <link href="http://www.javabin.cn/2023/milvus_mirror.html"/>
    <id>http://www.javabin.cn/2023/milvus_mirror.html</id>
    <published>2023-09-18T11:47:24.000Z</published>
    <updated>2024-03-11T14:49:03.606Z</updated>
    
    <content type="html"><![CDATA[<p>将本地milvus中的数据迁移到远程milvus服务中的操作流程。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>目录</li><li>主要操作步骤</li><li>详细操作步骤<ul><li>安装/配置milvus-backup</li><li>备份数据</li><li>安装/配置rclone/mc</li><li>迁移数据</li><li>恢复数据</li><li>修复索引</li></ul></li></ul><a id="more"></a><h2 id="主要操作步骤"><a href="#主要操作步骤" class="headerlink" title="主要操作步骤"></a>主要操作步骤</h2><p>通过尝试提供的milvus-dm等数据迁移工具，发现只有milvus-backup可以在最新版server下正常运行而不报错。</p><p>迁移数据的主要操作流程为：</p><ul><li>1.使用milvus-backup create 命令，备份数据到本地minio</li><li>2.使用rclone sync/mc mirror迁移数据到远程minio</li><li>3.使用milvus-backup restore命令，恢复数据</li><li>4.重新创建索引</li></ul><h2 id="详细操作步骤"><a href="#详细操作步骤" class="headerlink" title="详细操作步骤"></a>详细操作步骤</h2><h3 id="安装-配置milvus-backup"><a href="#安装-配置milvus-backup" class="headerlink" title="安装/配置milvus-backup"></a>安装/配置milvus-backup</h3><ol><li>安装编译milvus-backup</li></ol><pre><code class="shell">  git clone git@github.com:zilliztech/milvus-backup.git  cd milvus-backup  go get  go build</code></pre><ol><li>配置milvus-backup</li></ol><p>这里需要配置待备份的milvus和关联minio信息，以及backup数据存储位置。</p><pre><code class="yml"># Configures the system log output.log:  level: info # Only supports debug, info, warn, error, panic, or fatal. Default &#39;info&#39;.  console: true  file:    rootPath: &quot;logs/backup.log&quot;http:  simpleResponse: true# milvus proxy address, compatible to milvus.yamlmilvus:  address: localhost  # 配置milvus地址   port: 19530    # 配置milvus端口   authorizationEnabled: false  # tls mode values [0, 1, 2]  # 0 is close, 1 is one-way authentication, 2 is two-way authentication.  tlsMode: 0  user: &quot;root&quot;  password: &quot;Milvus&quot;# Related configuration of minio, which is responsible for data persistence for Milvus.minio:  address: localhost # Address of MinIO/S3  # 配置minio地址  port: 9000   # Port of MinIO/S3   # 配置minio端口   accessKeyID: minioadmin # accessKeyID of MinIO/S3     # 配置minio keyid  secretAccessKey: minioadmin # MinIO/S3 encryption string   # 配置minio  key   useSSL: false # Access to MinIO/S3 with SSL  useIAM: false  cloudProvider: &quot;aws&quot;  iamEndpoint: &quot;&quot;  bucketName: &quot;a-bucket&quot; # Milvus Bucket name in MinIO/S3, make it the same as your milvus instance  rootPath: &quot;files&quot; # Milvus storage root path in MinIO/S3, make it the same as your milvus instance  backupBucketName: &quot;backup&quot;  # 配置存储备份的bucket    backupRootPath: &quot;backup&quot;  # 配置存储备份的根路径backup:    maxSegmentGroupSize: 2G</code></pre><h3 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h3><p>执行milvus-backup create命令创建备份，如果按提供的配置，最终创建的云存储数据可在<code>http://localhost:9001/browser/backup/YmFja3VwLw==</code> 查看到</p><pre><code class="shell">  cd milvus-backup  ./milvus-backup create -n data_20130920</code></pre><h3 id="安装-配置rclone-mc"><a href="#安装-配置rclone-mc" class="headerlink" title="安装/配置rclone/mc"></a>安装/配置rclone/mc</h3><p>rclone/mc是一个用于同步云平台文件和目录的命令行工具。</p><ul><li>1 安装rclone或者mc（mc似乎比rclone慢，而且实际使用中频繁卡死在99.99%左右，非常难受）</li></ul><pre><code class="shell">wget https://downloads.rclone.org/v1.64.0/rclone-v1.64.0-linux-amd64.zipunzip rclone-v1.64.0-linux-amd64.zipcd rclone-v1.64.0-linux-amd64sudo cp rclone /usr/bin/sudo chmod 755 /usr/bin/rclonesudo mkdir -p /usr/local/share/man/rclonesudo cp rclone.1 /usr/local/share/man/rclone/sudo mandb</code></pre><ul><li>2 配置rclone</li></ul><p>编辑~/.config/rclone/rclone.conf文件，写入相关minio服务的相关配置。下面的配置文件中local_minio为本地minio服务配置，test_minio为测试环境minio服务配置。</p><pre><code class="yml">[local_minio]type = s3provider = minioadminenv_auth = falseaccess_key_id = minioadminsecret_access_key = minioadminregion = cn-east-1endpoint = http://localhost:9000location_constraint =server_side_encryption =[test_minio]type = s3provider = minioadminenv_auth = falseaccess_key_id = minioadminsecret_access_key = minioadminregion = cn-east-1endpoint = http://192.168.0.1:9000location_constraint =server_side_encryption =</code></pre><ul><li>3 测试rclone配置是否ok</li></ul><p>查看测试环境所有bucket: <code>rclone lsd test_minio</code></p><p>查看本地环境所有bucket: <code>rclone lsd local_minio</code></p><h3 id="迁移数据"><a href="#迁移数据" class="headerlink" title="迁移数据"></a>迁移数据</h3><p>通过rclone sync 将local_minio上的backup桶同步到test_minio上的backup桶.</p><pre><code class="shell">rclone sync -P local_minio:/backup test_minio:/backup</code></pre><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><ul><li>创建test_backup.yml文件。设置test_minio服务相关配置</li></ul><pre><code class="yml"># Configures the system log output.log:  level: info # Only supports debug, info, warn, error, panic, or fatal. Default &#39;info&#39;.  console: true  file:    rootPath: &quot;logs/test_backup.log&quot;http:  simpleResponse: true# milvus proxy address, compatible to milvus.yamlmilvus:  address: 192.168.0.1  # 【配置milvus地址】  port: 19530    # 配置milvus端口   authorizationEnabled: false  # tls mode values [0, 1, 2]  # 0 is close, 1 is one-way authentication, 2 is two-way authentication.  tlsMode: 0  user: &quot;root&quot;  password: &quot;Milvus&quot;# Related configuration of minio, which is responsible for data persistence for Milvus.minio:  address: 192.168.0.1 # Address of MinIO/S3  # 【配置minio地址】  port: 9000   # Port of MinIO/S3   # 配置minio端口   accessKeyID: minioadmin # accessKeyID of MinIO/S3     # 配置minio keyid  secretAccessKey: minioadmin # MinIO/S3 encryption string   # 配置minio  key   useSSL: false # Access to MinIO/S3 with SSL  useIAM: false  cloudProvider: &quot;aws&quot;  iamEndpoint: &quot;&quot;  bucketName: &quot;a-bucket&quot; # 【配置bucket名称】  rootPath: &quot;files&quot; # Milvus storage root path in MinIO/S3, make it the same as your milvus instance  backupBucketName: &quot;backup&quot;  # 配置存储备份的bucket    backupRootPath: &quot;backup&quot;  # 配置存储备份的根路径backup:    maxSegmentGroupSize: 2G</code></pre><ul><li>执行恢复命令<code>./milvus-backup --config test_backup.yml restore -c test_collection -n data_20130920</code></li></ul><h2 id="修复索引"><a href="#修复索引" class="headerlink" title="修复索引"></a>修复索引</h2><p>链接远程milvus服务，使用pymilvus sdk来重新创建刚刚导入的集合test_collection的索引</p><pre><code class="python3">  from pymilvus import Collection, connections  connections.connect(host=&#39;localhost&#39;, port=&#39;19530&#39;)  collection = Collection(name=&#39;test_collection&#39;)  collection.create_index(&#39;embedding&#39;, {      &quot;index_type&quot;: &quot;IVF_FLAT&quot;,      &quot;metric_type&quot;: &quot;IP&quot;,      &quot;params&quot;: {&quot;nlist&quot;: 1024},  })</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将本地milvus中的数据迁移到远程milvus服务中的操作流程。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;主要操作步骤&lt;/li&gt;
&lt;li&gt;详细操作步骤&lt;ul&gt;
&lt;li&gt;安装/配置milvus-backup&lt;/li&gt;
&lt;li&gt;备份数据&lt;/li&gt;
&lt;li&gt;安装/配置rclone/mc&lt;/li&gt;
&lt;li&gt;迁移数据&lt;/li&gt;
&lt;li&gt;恢复数据&lt;/li&gt;
&lt;li&gt;修复索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="运维" scheme="http://www.javabin.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="milvus" scheme="http://www.javabin.cn/tags/milvus/"/>
    
      <category term="数据迁移" scheme="http://www.javabin.cn/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"/>
    
  </entry>
  
  <entry>
    <title>【墨水屏】2.9寸墨水屏固件适配、二次开发，主控芯片：TLSR8359</title>
    <link href="http://www.javabin.cn/2022/epaper.html"/>
    <id>http://www.javabin.cn/2022/epaper.html</id>
    <published>2022-07-23T04:12:23.000Z</published>
    <updated>2024-03-11T15:05:51.362Z</updated>
    
    <content type="html"><![CDATA[<p>从闲鱼上淘了几块电子价签，发现大部分都是msp430的主控，要进行编程还比较麻烦，手头并没有设备。但是其中有一款主控为TLSR8359的2.9寸设备，github已经有相近型号固件的项目，只需要进行简单适配应该就可以运行。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>目录</li><li>最终适配好的项目<ul><li>下载项目</li><li>编译</li><li>烧录</li><li>蓝牙上传图片</li></ul></li><li>主控芯片TLSR8359<ul><li>运行流程(软件)</li></ul></li><li>墨水屏屏幕驱动方式<ul><li>三色墨水屏原理</li><li>屏幕驱动协议</li><li>分辨率适配</li><li>图像处理方式</li><li>常用绘图操作</li></ul></li><li>远程控制<ul><li>蓝牙交互方式</li></ul></li><li>图像抖动算法<ul><li>为何需要抖动</li><li>bayer 黑白</li><li>floydsteinberg 黑白 多色</li><li>Atkinson 黑白 多色</li></ul></li><li>资料、参考<ul><li>屏幕驱动资料</li><li>主控芯片资料</li><li>抖动算法资料</li></ul></li></ul><a id="more"></a><h1 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h1><h2 id="最终适配好的项目"><a href="#最终适配好的项目" class="headerlink" title="最终适配好的项目"></a>最终适配好的项目</h2><p>原始项目已适配了2.3寸墨水屏，但在2.9寸墨水屏上存在一些问题，且图片上传方式有些麻烦。</p><h3 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h3><p><a href="https://github.com/reece15/stellar-L3N-etag" target="_blank" rel="noopener">github项目</a></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>系统：windows</p><pre><code class="cmd">    cd Firmware    makeit.exe clean &amp;&amp; makeit.exe -j12</code></pre><p>Firmware目录下会生成.bin格式的固件</p><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><ul><li>拆开电池后盖查看主控是否为TLSR8359</li><li>焊接 GND, VCC, RX, RTS四根线。</li><li>使用usb2ttl模块(CH340)链接焊接的四根线。其中rx 链接 tx, tx链接 rx, vcc链接3.3v, GND链接 GND。RTS飞线和芯片CH340G第三脚链接（也可不焊，烧录前手动和GND连一下）。</li><li>打开<a href="https://atc1441.github.io/ATC_TLSR_Paper_UART_Flasher.html，" target="_blank" rel="noopener">https://atc1441.github.io/ATC_TLSR_Paper_UART_Flasher.html，</a> 波特率选择默认 460800，Atime默认，文件选择Firmware/ATC_Paper.bin</li><li>先点击unlock,再点击write to flush,等待完成。成功后，屏幕会自动刷新。</li></ul><h3 id="蓝牙上传图片"><a href="#蓝牙上传图片" class="headerlink" title="蓝牙上传图片"></a>蓝牙上传图片</h3><ul><li>运行 <code>cd web_tools &amp;&amp; python -m http.server</code></li><li>打开 <a href="http://127.0.0.1:8000" target="_blank" rel="noopener">http://127.0.0.1:8000</a> 后在页面上链接蓝牙</li><li>选择图片并上传，上传后可添加文字或者手动绘制文字。也可设置抖动算法。</li><li>发送到设备，等待屏幕刷新</li></ul><p><img src="/photo_2022/web.jpg" alt=""></p><h2 id="主控芯片TLSR8359"><a href="#主控芯片TLSR8359" class="headerlink" title="主控芯片TLSR8359"></a>主控芯片TLSR8359</h2><h3 id="运行流程-软件"><a href="#运行流程-软件" class="headerlink" title="运行流程(软件)"></a>运行流程(软件)</h3><p>执行流程：</p><ul><li>进入 主函数：main.c 的<code>int main (void)</code><ul><li>硬件初始化</li></ul></li><li>进入 app.c 的<code>main_loop</code>函数<ul><li>获取时间</li><li>获取温度，电量</li><li>更新屏幕内容 进入 epd.c <code>epd_update</code>函数<ul><li>根据设置的场景类型，调用不同场景处理函数，将场景显示到屏幕。</li><li>调用obd库对屏幕进行绘制。然后在EPD_Display函数中根据不同设备，调用不同的绘制函数。</li></ul></li><li>更新LED 状态</li><li>休眠屏幕设备</li></ul></li></ul><p>硬件部分可参考文末，TLSR8359 说明文档，或者从官网下载demo项目 2_4g_proprietary_sdk。</p><h2 id="墨水屏屏幕驱动方式"><a href="#墨水屏屏幕驱动方式" class="headerlink" title="墨水屏屏幕驱动方式"></a>墨水屏屏幕驱动方式</h2><h3 id="三色墨水屏原理"><a href="#三色墨水屏原理" class="headerlink" title="三色墨水屏原理"></a>三色墨水屏原理</h3><p>微胶囊电泳显示技术。墨水屏内部为悬浮在液体中的三色带电纳米微粒，通电后受电场影响移动而形成图案。本身不发光，通过反射环境光来显示图案。</p><p>程序上，要显示黑白色，只需要按位设置01数据，然后通过SPI写入屏幕RAM即可。其中1 代表 白色，0 代表黑色，即一字节可显示8个像素。</p><p>对于三色屏幕，内部有两片RAM，分别存储 黑白色和 红色。颜色对应关系：</p><table><thead><tr><th>黑白</th><th>红</th><th>显示颜色</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>黑</td></tr><tr><td>1</td><td>0</td><td>白</td></tr><tr><td>0</td><td>1</td><td>红</td></tr><tr><td>1</td><td>1</td><td>红</td></tr></tbody></table><h3 id="屏幕驱动协议"><a href="#屏幕驱动协议" class="headerlink" title="屏幕驱动协议"></a>屏幕驱动协议</h3><p>屏幕可参考SSD1680 的方式进行驱动，具体可参考 SSD1680.pdf的第39页，9.Operation Flow and Code Sequence ，详细命令的讲解可参考第20页命令表。</p><p>屏幕刷新流程为：</p><ul><li>通过SPI控制屏幕</li><li>发送0x12 进行SW重置 并等待10ms</li><li>发送0x01 驱动输出控制</li><li>发送0x11  设置数据扫描模式  00: Y轴自减，X轴自减；01: Y轴自减，X轴自增；10: Y轴自增，X轴自减；11: Y轴自增，X轴自增；</li><li>发送0x44  设置屏幕X轴 开始和结束位置。 计算方式 : 屏幕宽度/8 - 1 然后转换为 2字节数据。</li><li>发送0x45  设置屏幕Y轴 开始和结束位置。 计算方式 : (屏幕长度 - 1) 然后转换为 4字节数据。</li><li>发送0x3c Border Waveform Control</li><li>发送0x21 0x22 刷新控制</li><li>发送0x4E 设置RAM X轴 写入位置， 发送0X4F 设置RAM Y轴写入位置</li><li>发送0x24 开始写入 黑白 屏幕</li><li>发送0x26 开始写入 红 屏幕</li><li>发送0x22 0x20 显示数据</li><li>发送0x10 休眠屏幕</li></ul><h3 id="分辨率适配"><a href="#分辨率适配" class="headerlink" title="分辨率适配"></a>分辨率适配</h3><p>创建新设备的epd_bwr_xxx.c 和 .h文件, 修改 0x44 0x45 0x24 0x26命令处发送的屏幕大小相关数据。即可适配新的屏幕类型。</p><h3 id="图像处理方式"><a href="#图像处理方式" class="headerlink" title="图像处理方式"></a>图像处理方式</h3><p>普通图片数据需要 旋转90度，才是实际可正常显示的输入数据。</p><p>python转换图片为屏幕RAM数据：</p><pre><code class="python">    from PIL import Image    from PIL.Image import Dither # noqa    def bytes2hex(_bytes):        return &#39;&#39;.join(hex(item)[2:].zfill(2) for item in _bytes)    def image2hex(image, width=296, height=128, dither=Dither.NONE):        if isinstance(image, str):            image = Image.open(image)        image = image.resize((width, height)).rotate(90, expand=True)        # image.show()        return bytes2hex(image.resize((height, width)).convert(&#39;1&#39;, dither=dither).tobytes())    if __name__ == &#39;__main__&#39;:        path = &#39;1.png&#39;        print(image2hex(Image.open(path), dither=Dither.FLOYDSTEINBERG)</code></pre><h3 id="常用绘图操作"><a href="#常用绘图操作" class="headerlink" title="常用绘图操作"></a>常用绘图操作</h3><pre><code class="C">    // 绘制英文文字 从 x=1, y=17处开始绘制。不反色。    obdWriteStringCustom(&amp;obd, (GFXfont *)&amp;Dialog_plain_16, 1, 17, (char *)buff, 1);    // 绘制矩形 从 x=0, y=25处开始绘制 直到 295，27。颜色为黑色，且进行填充    obdRectangle(&amp;obd, 0, 25, 295, 27, 1, 1);    // 清空屏幕    obdFill(&amp;obd, 0, 0);</code></pre><h2 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h2><h3 id="蓝牙交互方式"><a href="#蓝牙交互方式" class="headerlink" title="蓝牙交互方式"></a>蓝牙交互方式</h3><p>TLSR8359支持低功耗蓝牙，可在app_att.c中添加蓝牙交互接口,读写权限。调用 bls_att_pushNotifyData 发送数据。</p><h2 id="图像抖动算法"><a href="#图像抖动算法" class="headerlink" title="图像抖动算法"></a>图像抖动算法</h2><h3 id="为何需要抖动"><a href="#为何需要抖动" class="headerlink" title="为何需要抖动"></a>为何需要抖动</h3><p>由于墨水屏一般只有 黑白或者黑白红，无法显示全部颜色，如果直接进行二值化，显示的图片将丢失很多明暗细节。可通过牺牲图像分辨率，通过控制局部像素点的稀疏来达到明暗变化的效果（黑白旧报纸或者黑白打印机的显示方式）</p><h3 id="bayer-黑白"><a href="#bayer-黑白" class="headerlink" title="bayer 黑白"></a>bayer 黑白</h3><p>取一个NxN的矩阵，将当前像素的x y坐标分别 对N 取余，可将xy 对应到 NxN中的一个位置，算出矩阵对应位置值+当前颜色值，根据其和阈值的大小关系决定当前位置显示黑色还是白色。</p><pre><code class="js">    const bayerThresholdMap = [        [  15, 135,  45, 165 ],        [ 195,  75, 225, 105 ],        [  60, 180,  30, 150 ],        [ 240, 120, 210,  90 ]      ];    const imageData = ctx.getImageData(0, 0, width, height);    const w = imageData.width;    //  遍历imageData currentPixel 为index    const x = currentPixel/4 % w;    const y = Math.floor(currentPixel/4 / w);    const map = Math.floor( (imageData.data[currentPixel] + bayerThresholdMap[x%4][y%4]) / 2 );    imageData.data[currentPixel] = (map &lt; threshold) ? 0 : 255;</code></pre><h3 id="floydsteinberg-黑白-多色"><a href="#floydsteinberg-黑白-多色" class="headerlink" title="floydsteinberg 黑白 多色"></a>floydsteinberg 黑白 多色</h3><ul><li>将当前RGB颜色转换到LAB颜色空间</li><li>在LAB颜色空间计算 当前像素颜色值 和 可选颜色距离最近的颜色。</li><li>计算出选择的颜色和当前颜色RGB通道的误差。</li><li>将误差传递到 当前像素的 右，左下，下，右下方像素。即给这些像素的RGB通道分别加上误差*比率。</li><li>重复执行，直到所有像素被处理。</li></ul><p>计算最近距离的颜色：</p><pre><code class="js">    function getNearColorV2(color, palette) {      let minDistanceSquared = 255*255 + 255*255 + 255*255 + 1;      let bestIndex = 0;      for (let i = 0; i &lt; palette.length; i++) {          let rdiff = (color[0] &amp; 0xff) - (palette[i][0] &amp; 0xff);          let gdiff = (color[1] &amp; 0xff) - (palette[i][1] &amp; 0xff);          let bdiff = (color[2] &amp; 0xff) - (palette[i][2] &amp; 0xff);          let distanceSquared = rdiff*rdiff + gdiff*gdiff + bdiff*bdiff;          if (distanceSquared &lt; minDistanceSquared) {              minDistanceSquared = distanceSquared;              bestIndex = i;          }      }      return palette[bestIndex];    }</code></pre><p>算法实现：</p><pre><code class="js">    const newColor = getNearColorV2(imageData.data.slice(currentPixel, currentPixel+4), palette);    const err = getColorErr(imageData.data.slice(currentPixel, currentPixel+4), newColor, 16);    updatePixel(imageData.data, currentPixel, newColor);    updatePixelErr(imageData.data, currentPixel +4, err, 7);    updatePixelErr(imageData.data, currentPixel + 4*w - 4, err, 3);    updatePixelErr(imageData.data, currentPixel + 4*w, err, 5);    updatePixelErr(imageData.data, currentPixel + 4*w + 4, err, 1);    function updatePixelErr(imageData, index, err, rate) {      imageData[index] += err[0] * rate;      imageData[index+1] += err[1] * rate;      imageData[index+2] += err[2] * rate;    }</code></pre><h3 id="Atkinson-黑白-多色"><a href="#Atkinson-黑白-多色" class="headerlink" title="Atkinson 黑白 多色"></a>Atkinson 黑白 多色</h3><ul><li>和 floydsteinberg 类似操作，不同是 将误差再传递到下下一行像素。</li></ul><p>算法实现：</p><pre><code class="js">    const newColor = getNearColorV2(imageData.data.slice(currentPixel, currentPixel+4), palette);    const err = getColorErr(imageData.data.slice(currentPixel, currentPixel+4), newColor, 8);    updatePixel(imageData.data, currentPixel, newColor);    updatePixelErr(imageData.data, currentPixel +4, err, 1);    updatePixelErr(imageData.data, currentPixel +8, err, 1);    updatePixelErr(imageData.data, currentPixel +4 * w - 4, err, 1);    updatePixelErr(imageData.data, currentPixel +4 * w, err, 1);    updatePixelErr(imageData.data, currentPixel +4 * w + 4, err, 1);    updatePixelErr(imageData.data, currentPixel +8 * w, err, 1);</code></pre><p>具体可参考 git项目的 /web_tools/js/dithering.js</p><h2 id="资料、参考"><a href="#资料、参考" class="headerlink" title="资料、参考"></a>资料、参考</h2><h3 id="屏幕驱动资料"><a href="#屏幕驱动资料" class="headerlink" title="屏幕驱动资料"></a>屏幕驱动资料</h3><blockquote><p>github项目 /docs/SSD1680.pdf<br><a href="https://mc.dfrobot.com.cn/thread-311306-3-1.html" target="_blank" rel="noopener">屏幕相关讨论</a><br><a href="https://www.waveshare.net/wiki/Pico-ePaper-2.9" target="_blank" rel="noopener">微雪2.9寸墨水屏</a></p></blockquote><h3 id="主控芯片资料"><a href="#主控芯片资料" class="headerlink" title="主控芯片资料"></a>主控芯片资料</h3><blockquote><p><a href="https://github.com/atc1441/ATC_TLSR_Paper" target="_blank" rel="noopener">ATC_Paper github 项目</a><br><a href="http://wiki.telink-semi.cn/wiki/solution/ESL/" target="_blank" rel="noopener">泰凌微TLSR8359相关资源</a><br>github项目 /docs/DS_TLSR8359-E_Datasheet for Telink ULP 2.4GHz RF SoC TLSR8359.pdf<br>github项目 /docs/Telink Kite BLE SDK Developer Handbook中文.pdf</p></blockquote><h3 id="抖动算法资料"><a href="#抖动算法资料" class="headerlink" title="抖动算法资料"></a>抖动算法资料</h3><blockquote><p><a href="https://www.codenong.com/12422407/" target="_blank" rel="noopener">多种抖动算法</a><br><a href="https://blog.csdn.net/qq_61888524/article/details/123858959" target="_blank" rel="noopener">颜色距离计算方式</a><br><a href="https://www.cnblogs.com/yanye0xff/p/16073279.html" target="_blank" rel="noopener">多种抖动矩阵</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从闲鱼上淘了几块电子价签，发现大部分都是msp430的主控，要进行编程还比较麻烦，手头并没有设备。但是其中有一款主控为TLSR8359的2.9寸设备，github已经有相近型号固件的项目，只需要进行简单适配应该就可以运行。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;最终适配好的项目&lt;ul&gt;
&lt;li&gt;下载项目&lt;/li&gt;
&lt;li&gt;编译&lt;/li&gt;
&lt;li&gt;烧录&lt;/li&gt;
&lt;li&gt;蓝牙上传图片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主控芯片TLSR8359&lt;ul&gt;
&lt;li&gt;运行流程(软件)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;墨水屏屏幕驱动方式&lt;ul&gt;
&lt;li&gt;三色墨水屏原理&lt;/li&gt;
&lt;li&gt;屏幕驱动协议&lt;/li&gt;
&lt;li&gt;分辨率适配&lt;/li&gt;
&lt;li&gt;图像处理方式&lt;/li&gt;
&lt;li&gt;常用绘图操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;远程控制&lt;ul&gt;
&lt;li&gt;蓝牙交互方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图像抖动算法&lt;ul&gt;
&lt;li&gt;为何需要抖动&lt;/li&gt;
&lt;li&gt;bayer 黑白&lt;/li&gt;
&lt;li&gt;floydsteinberg 黑白 多色&lt;/li&gt;
&lt;li&gt;Atkinson 黑白 多色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资料、参考&lt;ul&gt;
&lt;li&gt;屏幕驱动资料&lt;/li&gt;
&lt;li&gt;主控芯片资料&lt;/li&gt;
&lt;li&gt;抖动算法资料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="固件" scheme="http://www.javabin.cn/tags/%E5%9B%BA%E4%BB%B6/"/>
    
      <category term="C语言" scheme="http://www.javabin.cn/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="单片机" scheme="http://www.javabin.cn/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
      <category term="墨水屏" scheme="http://www.javabin.cn/tags/%E5%A2%A8%E6%B0%B4%E5%B1%8F/"/>
    
      <category term="抖动算法" scheme="http://www.javabin.cn/tags/%E6%8A%96%E5%8A%A8%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【3D打印机降噪】MKs gen l v2.1主板更换4988电机驱动为TMC2209</title>
    <link href="http://www.javabin.cn/2022/3dprinter-2209.html"/>
    <id>http://www.javabin.cn/2022/3dprinter-2209.html</id>
    <published>2022-04-13T14:14:46.000Z</published>
    <updated>2024-03-11T14:49:03.590Z</updated>
    
    <content type="html"><![CDATA[<p>3d打印机晚上运行时，噪音非常影响睡眠，可通过将自带的4988电机驱动更新到静音驱动tmc2208或者tmc2209来解决。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>硬件情况</li><li>噪音产生的原因</li><li>电机噪音处理<ul><li>更换方法</li><li>跳帽接法</li><li>故障处理：电压调试</li></ul></li><li>其他噪音的处理方法<ul><li>主机震动</li><li>散热器风扇<ul><li>打印头</li><li>物料</li><li>开关电源</li></ul></li></ul></li><li>效果<a id="more"></a></li></ul><h2 id="硬件情况"><a href="#硬件情况" class="headerlink" title="硬件情况"></a>硬件情况</h2><ul><li>结构: corexy</li><li>主板：MKs gen l v2.1</li><li>电机驱动: 4988 * 5 (xy轴各一个，z轴两个，挤出机一个)</li><li>电源: 220v30A</li></ul><h2 id="噪音产生的原因"><a href="#噪音产生的原因" class="headerlink" title="噪音产生的原因"></a>噪音产生的原因</h2><ul><li>电机运动时的噪音：<ul><li>主要是4988电机驱动驱动步进电机不足够平滑，导致电机运动发出振动和噪音。参考<a href="https://www.jianshu.com/p/33f3f44b7840?ivk_sa=1024320u" target="_blank" rel="noopener">TMC2208与A4988步进电机驱动对比分析</a></li><li>运动时和轴的摩擦，刚组装的新机几乎无声。</li></ul></li><li>运动导致的框架振动。</li><li>散热器风扇<ul><li>3d打印机工作时，打印头需要持续散热维持稳定的温度；</li><li>而物料也需要风扇来使其在出打印头快速冷却下来，实现搭桥打印；</li><li>开关电源电流一般得10A以上，也需要风扇暴力散热。</li></ul></li></ul><h2 id="电机噪音处理"><a href="#电机噪音处理" class="headerlink" title="电机噪音处理"></a>电机噪音处理</h2><h3 id="升级方法"><a href="#升级方法" class="headerlink" title="升级方法"></a>升级方法</h3><h4 id="1-准备清单"><a href="#1-准备清单" class="headerlink" title="1. 准备清单"></a>1. 准备清单</h4><p>corexy结构的3d打印机，一般只需要更换运动比较频繁的 x轴，z轴和 挤出机电机即可。<br>物料清单：</p><ul><li>tmc2209 * 3 （也可以全换了 5个）</li><li>万用表 * 1</li></ul><h4 id="2-更换方法"><a href="#2-更换方法" class="headerlink" title="2. 更换方法"></a>2. 更换方法</h4><ul><li>注意！注意4988和tmc2209的引脚，tmc2209的GND引脚必须和主板上原来4988的gnd位置一致，<code>注意：如果插反，2209电机驱动板将会烧毁</code>。</li><li>1.拔下4988并记下GND位置。</li><li>2.将跳帽接到右上方两个。其他拔掉。如果是从4988升级，也就是拔掉最后一个。具体看下面的图。</li><li>3.对齐GND脚，插入tmc2209驱动</li><li>4.拔下电机的连接线（<code>注意：这一步需要操作，防止下一步损坏电机</code>）,每个驱动板旁边就是他的电机接口。具体参考<a href="https://blog.csdn.net/gjy_skyblue/article/details/119872104" target="_blank" rel="noopener">MKS GEN_L V2.1使用说明书</a></li><li>5.使用电压表测量电压调节螺丝和gnd引脚之间的电压，将电压调到0.96到1v左右即可，电压太高会导致电机过热而丢步。顺时钟旋转减小，逆时针增大。<code>注意：不要提前装装散热片，不好操作，会拧掉调节螺丝</code></li><li>6.将电机连接线翻转后插入。（如果不翻转，测试时将会看到电机的运动方向和实际相反）</li><li>7.装上驱动板散热器。</li><li>8.其他驱动按上面的操作即可。</li><li>9.测试：单独控制xyz测试是否正常</li><li>10.测试：自动回零和打印是否正常。如果丢步就再调小下电压；如果打印头运动方向相反，就翻转下对应的电机连接线。</li></ul><h3 id="跳帽接法"><a href="#跳帽接法" class="headerlink" title="跳帽接法"></a>跳帽接法</h3><p>将跳帽接到右上方两个。其他拔掉。如果是从4988升级，拔掉最后一个就行。<br><img src="/photo_2022/tm.png" alt="跳帽接法"></p><h3 id="故障处理：电压调试"><a href="#故障处理：电压调试" class="headerlink" title="故障处理：电压调试"></a>故障处理：电压调试</h3><p>红笔接螺丝，黑笔接GND。用起子旋转螺丝即可。<br><img src="/photo_2022/tmc2209.png" alt="电压调试位置"></p><h2 id="其他噪音的处理方法"><a href="#其他噪音的处理方法" class="headerlink" title="其他噪音的处理方法"></a>其他噪音的处理方法</h2><h3 id="主机震动"><a href="#主机震动" class="headerlink" title="主机震动"></a>主机震动</h3><p>使用海绵或者橡胶垫，垫在四角即可。</p><h3 id="散热器风扇"><a href="#散热器风扇" class="headerlink" title="散热器风扇"></a>散热器风扇</h3><ul><li>打印头<ul><li>将电源线接到散热器控制口，进行控制；</li><li>或者使用低转速风扇，打印头无需太强散热。我目前使用低转速风扇。</li></ul></li><li>物料<ul><li>使用静音风扇。风扇噪音情况: 液压轴承&gt;含油轴承&gt;滚珠轴承，买静音（转速不高）的液压轴承风扇换上即可。</li><li>并联两个风扇，降低风扇电压，转速。</li><li>串联电位器对风扇调速，注意对电位器贴散热片。（支持pwm调速的风扇可直接使用pwm调低转速）。</li><li>打印消音装置并安装。这个我打印了几个，试了下，效果并不明显，<a href="https://www.thingiverse.com/" target="_blank" rel="noopener">thingiverse</a>上大部分的消音装置, 网友都反馈效果不明显。</li><li>我目前使用低转速液压风扇，几乎无声。</li></ul></li><li>开关电源<ul><li>更换10A下无散热的电源。如果电流不足，可对热床单独供电。</li><li>同物料。</li><li>我目前还未更换。</li></ul></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>更换完后，目前最近距离只能听到电源风扇声音。其他几乎无声。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;3d打印机晚上运行时，噪音非常影响睡眠，可通过将自带的4988电机驱动更新到静音驱动tmc2208或者tmc2209来解决。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;硬件情况&lt;/li&gt;
&lt;li&gt;噪音产生的原因&lt;/li&gt;
&lt;li&gt;电机噪音处理&lt;ul&gt;
&lt;li&gt;更换方法&lt;/li&gt;
&lt;li&gt;跳帽接法&lt;/li&gt;
&lt;li&gt;故障处理：电压调试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他噪音的处理方法&lt;ul&gt;
&lt;li&gt;主机震动&lt;/li&gt;
&lt;li&gt;散热器风扇&lt;ul&gt;
&lt;li&gt;打印头&lt;/li&gt;
&lt;li&gt;物料&lt;/li&gt;
&lt;li&gt;开关电源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;效果
    
    </summary>
    
    
      <category term="硬件" scheme="http://www.javabin.cn/tags/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>【虚拟现实】Oculus Quest2, Pico neo3, 三星玄龙MR+虚拟现实头显真实使用体验</title>
    <link href="http://www.javabin.cn/2022/vr.html"/>
    <id>http://www.javabin.cn/2022/vr.html</id>
    <published>2022-04-04T06:47:24.000Z</published>
    <updated>2024-03-11T14:49:03.613Z</updated>
    
    <content type="html"><![CDATA[<p>目前购买并体验了三台vr设备，分别是facebook的quest2, 国内的pico neo3和三星的玄龙MR+, 其中前两款是一体机，最后一款是vr头显。下面谈一下各个设备的使用体验。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>目录</li><li>先说结论<ul><li>如何选择</li><li>购买渠道</li><li>多久会玩腻？vr设备缺点</li></ul></li><li>vr设备相关基本概念<ul><li>一体机</li><li>头显</li><li>可视角度</li><li>单眼分辨率</li><li>屏幕类型</li><li>屏幕刷新率</li><li>定位系统</li><li>有线串流</li><li>无线串流</li></ul></li><li>quest2, pico neo3, mr+对比<ul><li>参数、体验对比</li><li>quest2体验</li><li>pico neo3体验</li></ul></li><li>游戏和应用推荐</li><li>配件选购</li><li>quest2 常见问题</li><li>pico neo3 常见问题</li><li>mr+ 常见问题</li><li>如何开发vr游戏demo并在设备上运行<ul><li>pico neo3</li></ul></li></ul><a id="more"></a><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul><li>1.如果是想体验<code>海量vr游戏</code>，看vr电影，首选装满游戏的<code>oculus quest2</code>+舒适头戴。如果购买默认没有安装游戏的quest2, 还需要电脑科学上网后使用SSTAP分享网络对设备进行激活和升级。</li><li>2.如果喜欢看电影和进行<code>在线</code>互动且不在意<code>主流游戏支持程度</code>，可选 <code>pico neo3</code>。pico支持的游戏少的可怜。</li><li>3.如果<code>囊中羞涩</code>，且自身电脑显卡性能高于等于<code>GTX1660TI</code>， 可选 <code>三星玄龙MR+</code>。</li><li>4.如果你让我只推荐一个，我推荐Oculus quest2。</li></ul><h3 id="购买渠道"><a href="#购买渠道" class="headerlink" title="购买渠道"></a>购买渠道</h3><h4 id="1-海鲜市场-闲鱼"><a href="#1-海鲜市场-闲鱼" class="headerlink" title="1.海鲜市场(闲鱼)"></a>1.海鲜市场(闲鱼)</h4><p><code>quest2 128GB</code> 一手最低价1900+，一般2000左右，二手价格和一手价格一致。闲鱼上基本刚挂上就会有人买。</p><p><code>pico neo3 128GB带包+先锋卡</code>，我是1650收的，现在1400+就可收到。</p><p><code>三星玄龙mr+</code> 1100+可以收到，我当时是1700收的，1480卖的。</p><h4 id="2-官方渠道"><a href="#2-官方渠道" class="headerlink" title="2.官方渠道"></a>2.官方渠道</h4><p><code>quest2 128GB</code> 天猫海外直邮，有活动时 1950-2015元左右，一般10天送到（日本发货-国际航班-海关-清关-国内快递转运，国外一周，国内三天）。微信小程序 亚马逊一般含税2100左右（速度更慢）。</p><p><code>pico neo3</code> 旗舰店 2499，打卡180天返费一半，相当于半价（需要每天晃动手柄半小时以上且进行签到）。</p><p><code>三星玄龙mr+</code> 前几年京东4399+。现在官方已经下架。</p><h3 id="多久会玩腻？vr设备缺点"><a href="#多久会玩腻？vr设备缺点" class="headerlink" title="多久会玩腻？vr设备缺点"></a>多久会玩腻？vr设备缺点</h3><p>一般一到两个月左右就会吃灰。原因是： </p><ul><li>太累。普通PC，switch, ps主机玩游戏并不需要肢体大幅度运动，而vr游戏一般都需要身体和双手大幅度移动来控制游戏，长时间使用非常累。 </li><li>舒适度不够。目前家用的vr设备体积和重量还是很大，使用时间稍长就会感觉压鼻子，压眼睛，勒脑壳（特别是quest2，重量全在前方，非常不舒服）。而且使用vr设备看电影躺着并不舒服，要么设备太重压脸（quest2）；要么脑壳后方的系的带子不平，导致平躺硌脑壳（pico neo3, mr+）。 </li><li>起雾。虽然可以使用vr设备进行健身游戏，但是头戴内部的镜片会很快起雾，必须频繁擦拭才行。</li><li>可玩性有限。元宇宙概念吹的很大，但是现在还只是把屏幕戴脑壳上然后玩个游戏，看个电影，线上互动下。而且游戏和PC，主机比 还是差很多，大部分都是小游戏级别。</li></ul><h2 id="vr设备相关基本概念"><a href="#vr设备相关基本概念" class="headerlink" title="vr设备相关基本概念"></a>vr设备相关基本概念</h2><h4 id="一体机"><a href="#一体机" class="headerlink" title="一体机"></a>一体机</h4><p>设备既要显示图像，还需要责数据处理，图像渲染。一般有自己的操作系统，可以无需链接电脑，单独运行。</p><h3 id="头显"><a href="#头显" class="headerlink" title="头显"></a>头显</h3><p>设备只是一个特殊的显示器。图像的渲染需要PC来提供。一般没有操作系统，必须链接电脑才可以运行。</p><h3 id="可视角度"><a href="#可视角度" class="headerlink" title="可视角度"></a>可视角度</h3><p>FOV. 可视角度范围。FOV越大越好。人肉眼最大可到220度，中心60度左右最新清晰。vr设备FOV太小会影响沉浸感，即会有一种透过望远镜看东西的感觉，两侧有大范围黑色的盲区。</p><h3 id="单眼分辨率"><a href="#单眼分辨率" class="headerlink" title="单眼分辨率"></a>单眼分辨率</h3><p>vr设备单个屏幕的分辨率。分辨率越高越好。vr设备分辨率太小会让人感觉到模糊，并且纱窗效应很强烈。纱窗效应类似于当你看电视时，凑近电视屏幕，即可以看到图像是密密麻麻的像素点组成，在这个距离，你的眼睛已经可以明显感受到图像是由纵横的像素组成，非常影响沉浸感。</p><h3 id="屏幕类型"><a href="#屏幕类型" class="headerlink" title="屏幕类型"></a>屏幕类型</h3><p>参考手机屏幕类型。</p><h3 id="屏幕刷新率"><a href="#屏幕刷新率" class="headerlink" title="屏幕刷新率"></a>屏幕刷新率</h3><p>参考手机屏幕刷新率</p><h3 id="定位系统"><a href="#定位系统" class="headerlink" title="定位系统"></a>定位系统</h3><p>手柄移动时，需要判断手柄移动的速度和位置，来控制vr场景中的人物动作。定位系统会影响到游戏的流畅性。目前常见的定位系统有：陀螺仪，图像识别, 基站定位。<br>基站定位： 效果最好，精度最高，最贵，可全身追踪。缺点是：和其他的相比安装麻烦，比较贵。<br>图像识别：性价比最高，大部分就是这个。缺点是 1.不能关灯或者在光线太暗的环境使用 2.如果手伸到身后或其他特殊角度，导致头显上的摄像头看不到，就会突然丢失手柄位置。3.稳定性受图像识别算法的影响<br>陀螺仪： 手机和其他山寨盒子。</p><h3 id="有线串流"><a href="#有线串流" class="headerlink" title="有线串流"></a>有线串流</h3><p>如果想玩stream,OCULUS等PC平台的游戏，就需要进行PC串流，实际就是将一体机当做头显来使用。这时候可以使用串流线（如usb3.0, usb3.1 gen1, usb3.1 gen2链接线）来链接电脑进行有线串流。<br>即电脑运行游戏后，将画面串流到vr设备屏幕上。<br>优点是：画面流畅 延迟小，<br>缺点是：需要链接线，最好准备至少3米的usb3.0以上的链接线。</p><h3 id="无线串流"><a href="#无线串流" class="headerlink" title="无线串流"></a>无线串流</h3><p>和有线串流差不多，只不过是将串流线换成了wifi，一般需要wifi6+5G来提供流畅的链接。<br>优点是：没有线的束缚，自由；<br>缺点是：如果路由器带宽不行，那么延迟较大，容易受干扰而卡顿；</p><h2 id="quest2-pico-neo3-mr-对比"><a href="#quest2-pico-neo3-mr-对比" class="headerlink" title="quest2, pico neo3, mr+对比"></a>quest2, pico neo3, mr+对比</h2><h3 id="参数、体验对比"><a href="#参数、体验对比" class="headerlink" title="参数、体验对比"></a>参数、体验对比</h3><table><thead><tr><th>项目</th><th>quest2</th><th>pico neo3</th><th>mr+</th></tr></thead><tbody><tr><td>类型</td><td><font color="#008000">一体机</font></td><td><font color="#008000">一体机</font></td><td>头显</td></tr><tr><td>单眼分辨率</td><td><font color="#008000">1832x1920</font></td><td><font color="#008000">1832x1920</font></td><td>1440x1600</td></tr><tr><td>可视角度</td><td>90</td><td>90</td><td><font color="#008000">110</font></td></tr><tr><td>定位系统</td><td><font color="#008000">图像识别</font></td><td>图像识别</td><td>图像识别</td></tr><tr><td>屏幕类型</td><td>LCD</td><td>LCD</td><td><font color="#008000">OLED</font></td></tr><tr><td>屏幕刷新率</td><td><font color="#008000">60-120HZ</font></td><td>72-90HZ</td><td>单元格</td></tr><tr><td>有线串流</td><td><font color="#008000">支持</font></td><td><font color="#008000">支持</font></td><td><font color="#008000">支持</font></td></tr><tr><td>无线串流</td><td><font color="#008000">支持</font></td><td><font color="#008000">支持</font></td><td>不支持</td></tr><tr><td>购买渠道</td><td>海外代购,天猫直邮,亚马逊微信小程序</td><td><font color="#008000">国内旗舰店</font></td><td>闲鱼</td></tr><tr><td>支持pc平台</td><td>stream/ocolus</td><td>stream</td><td><font color="#008000">微软虚拟门户/stream/ocolus</font></td></tr><tr><td>支持游戏/应用数量</td><td><font color="#008000">很多</font></td><td>少</td><td>少</td></tr><tr><td>一手价格</td><td><font color="#008000">1950-2200</font></td><td>2399</td><td>无</td></tr><tr><td>二手价格</td><td>1900-2100</td><td>1600-1800</td><td><font color="#008000">1100</font></td></tr><tr><td>手势识别</td><td><font color="#008000">支持</font></td><td>不支持</td><td>不支持</td></tr><tr><td>清晰度(个人体验)</td><td><font color="#008000">很清晰</font></td><td>清晰</td><td>有纱窗效应，远处模糊</td></tr><tr><td>纱窗感(个人体验)</td><td><font color="#008000">几乎无</font></td><td><font color="#008000">几乎无</font></td><td>有</td></tr><tr><td>丢失手柄追踪(个人体验)</td><td><font color="#008000">少</font></td><td>偶尔</td><td>偶尔</td></tr><tr><td>卡顿(个人体验)</td><td><font color="#008000">几乎无</font></td><td>偶尔</td><td>偶尔</td></tr><tr><td>系统稳定性(个人体验)</td><td><font color="#008000">稳定</font></td><td>一般（偶尔重启）</td><td>差，需要反复插拔</td></tr><tr><td>安装难易(个人体验)</td><td>难，需科学上网，激活，facebook账户</td><td><font color="#008000">易</font></td><td><font color="#008000">易</font></td></tr><tr><td>看电影效果(个人体验)</td><td><font color="#008000">清晰，流畅</font></td><td><font color="#008000">清晰，流畅</font></td><td><font color="#008000">清晰，流畅</font></td></tr><tr><td>舒适度(个人体验)</td><td>不舒适</td><td><font color="#008000">舒适</font></td><td>一般</td></tr></tbody></table><h3 id="quest2体验"><a href="#quest2体验" class="headerlink" title="quest2体验"></a>quest2体验</h3><p>优点：清晰，流畅，游戏和应用非常多，支持手势识别，系统稳定。<br>缺点：初次激活需要facebook账户登录；联机没有体验过，必须开sstap全局代理和科学上网，比较麻烦；使用stream联机big screen经常卡顿，且频道内都是外语交流。</p><p><img src="/photo_2022/quest2.jpg" alt="quest2.jpg"></p><h3 id="pico-neo3体验"><a href="#pico-neo3体验" class="headerlink" title="pico neo3体验"></a>pico neo3体验</h3><p>优点：清晰，流畅，线上互动（多人影院，多人绘画，pico home影院，多人射击游戏）由于流量直接走的国内，体验非常流畅，国人很多。<br>缺点：游戏中心的游戏很少。大部分热门游戏只能通过stream串流玩。</p><p><img src="/photo_2022/picneo3.jpg" alt="picneo3.jpg"></p><h3 id="MR-体验"><a href="#MR-体验" class="headerlink" title="MR+体验"></a>MR+体验</h3><p>优点： 便宜; 可以串流玩stream平台,windows MR平台, Oculus平台;fov大，沉浸感强.<br>缺点： 有纱窗感（并不会影响游戏和观影，但是当你稍微细看，或者画面切换时，会立马有纱窗感）；远处模糊；</p><p><img src="/photo_2022/mr.jpg" alt="mr.jpg"></p><h2 id="配件选购"><a href="#配件选购" class="headerlink" title="配件选购"></a>配件选购</h2><h3 id="quest2"><a href="#quest2" class="headerlink" title="quest2"></a>quest2</h3><ul><li>舒适头戴。必选，不然体验非常差。淘宝，京东 100元左右。</li><li>科学上网。必选。<a href="https://ds2.club/22662d8" target="_blank" rel="noopener">科学上网</a></li><li>串流线。可选。闲鱼25元左右。</li><li>近视眼镜片。可选。 闲鱼80元+，淘宝180元+。</li><li>手柄保护套。可选。</li><li>gtx1660ti+显卡。可选。不进行stream串流的话，不需要。</li><li>充电电池。必选。京东 倍量充电电池 4节+充电器</li></ul><h3 id="pico-neo3"><a href="#pico-neo3" class="headerlink" title="pico neo3"></a>pico neo3</h3><ul><li>先锋卡激活码。必选。送四款游戏。（不选这个，几乎无任何游戏可玩，只能看电影和串流stream）</li><li>打卡返现激活码。可选。每天必须晃动手柄30分钟且签到，持续180天，可返一半现金。</li><li>收纳包。可选。会赠送。</li><li>串流线。可选。闲鱼25元左右。</li><li>近视眼镜片。可选。 闲鱼80元+，淘宝180元+。</li><li>手柄保护套。可选</li><li>gtx1660ti+显卡。可选。stream串流的话，需要。</li><li>充电电池。必选。京东 倍量充电电池 4节+充电器</li></ul><h3 id="MR"><a href="#MR" class="headerlink" title="MR+"></a>MR+</h3><ul><li>gtx1660ti+显卡。必选</li><li>充电电池。必选。京东 倍量充电电池 4节+充电器</li><li>近视眼镜片。可选。 闲鱼80元+，淘宝180元+。</li></ul><h2 id="游戏和应用推荐"><a href="#游戏和应用推荐" class="headerlink" title="游戏和应用推荐"></a>游戏和应用推荐</h2><h3 id="steam"><a href="#steam" class="headerlink" title="steam"></a>steam</h3><ul><li>半衰期。神作，真实度最高，射击，恐怖，变异生物。</li><li>节奏光剑。运动，音乐游戏，热门游戏。</li><li>燥热。射击，子弹时间。</li><li>美丽水世界。剧情</li><li>宇宙模拟器。真实数据还原宇宙目前所有已知天体，天文，科幻。</li><li>宇宙沙盒2。宇宙天体运动模拟。</li><li>热狗、马蹄和手榴弹。枪械模拟，射击。</li><li>Pistol Whip。 射击。</li><li>渔夫的故事。剧情。</li><li>乒乓球。运动，体育竞技。</li><li>假日模拟器。模拟。</li><li>机械重装。射击</li><li>夏日乐园。模拟，过山车，攀爬，射击，赛车，电影，游乐园其他项目。</li><li>深蓝。深海体验，vr体验。</li><li>onshape。墙来了，运动健身。</li><li>笔刷。vr作画。</li><li>虚拟桌面。无线串流</li><li>the lab。stream自带，模拟。</li><li>big screen. 模拟电影院，线上互动。</li><li>vrchat。虚拟社交，线上互动。</li></ul><h3 id="quest2-1"><a href="#quest2-1" class="headerlink" title="quest2"></a>quest2</h3><ul><li>节奏光剑。运动，音乐游戏，热门游戏。</li><li>乒乓球。运动，体育竞技。</li><li>燥热。射击，子弹时间。</li><li>onshape。墙来了，运动健身。</li><li>google画笔，重力草图。vr作画。</li><li>Pistol Whip。 射击。</li><li>假日模拟器。模拟。</li><li>夏日乐园。模拟，过山车，攀爬，射击，赛车，电影，游乐园其他项目。</li><li>风暴之地。射击</li><li>不惧跌倒。砍杀，魔法。</li><li>荣耀胸章。战争，射击。</li><li>多合一运动。运动，体育竞技。</li><li>巫师的华尔兹。魔法，手部追踪。</li><li>渔夫的故事。剧情。</li><li>莫斯。剧情。</li><li>七彩鸭传奇。剧情，电影。</li><li>红色物质。剧情。</li><li>水果忍者。切水果。</li><li>虚拟画廊。</li></ul><h3 id="pico-neo3-1"><a href="#pico-neo3-1" class="headerlink" title="pico neo3"></a>pico neo3</h3><p>游戏中心的游戏过少。无需推荐。可无线串流stream平台使用。</p><p>推荐先锋卡选择的游戏：</p><ul><li>亚利桑那阳光</li><li>乒乓球</li></ul><h3 id="mr"><a href="#mr" class="headerlink" title="mr+"></a>mr+</h3><ul><li>Halo Recruit. 射击</li><li>Halo tour. 旅游，风景，罗马。</li><li>veer。 vr视频。</li><li>free the light. vr体验。</li><li>invasion vr. 剧情。</li></ul><h3 id="quest2-常见问题"><a href="#quest2-常见问题" class="headerlink" title="quest2 常见问题"></a>quest2 常见问题</h3><h3 id="如何激活设备？"><a href="#如何激活设备？" class="headerlink" title="如何激活设备？"></a>如何激活设备？</h3><ul><li>方法1： 安装87vr软件，进行一键激活。</li><li>方法2： 找人（闲鱼就有）帮忙激活</li><li>方法3： 准备科学上网工具，sstap软件，注册facebook账户。根据网络上的教程自行尝试。</li></ul><h3 id="如何下载学习版游戏"><a href="#如何下载学习版游戏" class="headerlink" title="如何下载学习版游戏"></a>如何下载学习版游戏</h3><ul><li>先根据网络上的教程开启开发者模式。 </li><li>设备内安装 87VR应用中心</li></ul><h3 id="近视怎么办？"><a href="#近视怎么办？" class="headerlink" title="近视怎么办？"></a>近视怎么办？</h3><ul><li>可直接带眼镜使用，但是容易刮花屏幕</li><li>去淘宝或者闲鱼，配一副 适合的 眼镜片。</li></ul><h3 id="不清晰"><a href="#不清晰" class="headerlink" title="不清晰"></a>不清晰</h3><ul><li>尝试调节瞳距 </li><li>尝试调整头戴的松紧</li></ul><h2 id="pico-neo3-常见问题"><a href="#pico-neo3-常见问题" class="headerlink" title="pico neo3 常见问题"></a>pico neo3 常见问题</h2><h3 id="手柄失灵或者设备卡顿"><a href="#手柄失灵或者设备卡顿" class="headerlink" title="手柄失灵或者设备卡顿"></a>手柄失灵或者设备卡顿</h3><p>升级系统到最新版</p><h3 id="无线串流卡顿，画面让人感觉眩晕"><a href="#无线串流卡顿，画面让人感觉眩晕" class="headerlink" title="无线串流卡顿，画面让人感觉眩晕"></a>无线串流卡顿，画面让人感觉眩晕</h3><ul><li>降低屏幕刷新率</li><li>降低清晰度</li><li>降低stream vr采样率</li><li>使用wifi6 路由器</li><li>使用有线串流</li><li>升级pc端串流软件</li></ul><h2 id="mr-常见问题"><a href="#mr-常见问题" class="headerlink" title="mr+ 常见问题"></a>mr+ 常见问题</h2><h3 id="设备链接异常"><a href="#设备链接异常" class="headerlink" title="设备链接异常"></a>设备链接异常</h3><ul><li>重新插拔usb</li><li>卸载windows mr 后重新安装</li><li>更新NVIDIA显卡驱动</li></ul><h2 id="如何开发vr游戏demo并在设备上运行"><a href="#如何开发vr游戏demo并在设备上运行" class="headerlink" title="如何开发vr游戏demo并在设备上运行"></a>如何开发vr游戏demo并在设备上运行</h2><h3 id="pico-neo3-2"><a href="#pico-neo3-2" class="headerlink" title="pico neo3"></a>pico neo3</h3><p>如果已经会js等其他开发语言，按以下内容学习即可（预计需要6-10小时，可以达到自己的demo游戏在设备里运行，可操作手柄，移动，进行场景交互），之后就是unity的学习了。</p><ul><li>pico neo3 环境创建, 参考这个视频: <a href="https://www.bilibili.com/video/BV1Sy4y1K7Nd?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Sy4y1K7Nd?spm_id_from=333.337.search-card.all.click</a></li><li>unity开发vr程序，参考这个视频：<a href="https://www.bilibili.com/video/BV1Yt4y1y7sx?spm_id_from=333.999.0.0" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yt4y1y7sx?spm_id_from=333.999.0.0</a></li><li>3d模型下载，网站：<a href="https://3dexport.com/free-3d-models/format(fbx" target="_blank" rel="noopener">https://3dexport.com/free-3d-models/format(fbx</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前购买并体验了三台vr设备，分别是facebook的quest2, 国内的pico neo3和三星的玄龙MR+, 其中前两款是一体机，最后一款是vr头显。下面谈一下各个设备的使用体验。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;目录&lt;/li&gt;
&lt;li&gt;先说结论&lt;ul&gt;
&lt;li&gt;如何选择&lt;/li&gt;
&lt;li&gt;购买渠道&lt;/li&gt;
&lt;li&gt;多久会玩腻？vr设备缺点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;vr设备相关基本概念&lt;ul&gt;
&lt;li&gt;一体机&lt;/li&gt;
&lt;li&gt;头显&lt;/li&gt;
&lt;li&gt;可视角度&lt;/li&gt;
&lt;li&gt;单眼分辨率&lt;/li&gt;
&lt;li&gt;屏幕类型&lt;/li&gt;
&lt;li&gt;屏幕刷新率&lt;/li&gt;
&lt;li&gt;定位系统&lt;/li&gt;
&lt;li&gt;有线串流&lt;/li&gt;
&lt;li&gt;无线串流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;quest2, pico neo3, mr+对比&lt;ul&gt;
&lt;li&gt;参数、体验对比&lt;/li&gt;
&lt;li&gt;quest2体验&lt;/li&gt;
&lt;li&gt;pico neo3体验&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;游戏和应用推荐&lt;/li&gt;
&lt;li&gt;配件选购&lt;/li&gt;
&lt;li&gt;quest2 常见问题&lt;/li&gt;
&lt;li&gt;pico neo3 常见问题&lt;/li&gt;
&lt;li&gt;mr+ 常见问题&lt;/li&gt;
&lt;li&gt;如何开发vr游戏demo并在设备上运行&lt;ul&gt;
&lt;li&gt;pico neo3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="测评" scheme="http://www.javabin.cn/tags/%E6%B5%8B%E8%AF%84/"/>
    
      <category term="科技" scheme="http://www.javabin.cn/tags/%E7%A7%91%E6%8A%80/"/>
    
      <category term="虚拟现实" scheme="http://www.javabin.cn/tags/%E8%99%9A%E6%8B%9F%E7%8E%B0%E5%AE%9E/"/>
    
  </entry>
  
  <entry>
    <title>【爬虫】cloudflare反爬虫机制绕过方法</title>
    <link href="http://www.javabin.cn/2022/bot.html"/>
    <id>http://www.javabin.cn/2022/bot.html</id>
    <published>2022-03-07T14:14:46.000Z</published>
    <updated>2024-03-11T14:49:03.592Z</updated>
    
    <content type="html"><![CDATA[<p>当我们爬取cloudflare保护的网站时，网页会停留在跳转页面，然后运行一堆js来检测你的浏览器环境是不是真实用户访问，<br>如果检测不通过，就会一直卡在跳转页面，爬虫无法正常访问真实网页。如何解决？</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>爬虫检测网页[工具]</li><li>常见前端反爬虫方式</li><li>常见解决方法</li><li>如何解决</li><li>cloudflare调试方法</li><li>有用的一些链接和参考资料<a id="more"></a></li></ul><h2 id="爬虫检测网页"><a href="#爬虫检测网页" class="headerlink" title="爬虫检测网页"></a>爬虫检测网页</h2><p>可使用你的爬虫打开这个<a href="/bot/bot.html">爬虫检测</a>网页，查看爬虫是否可以被检测到。</p><h2 id="常见前端反爬虫方式"><a href="#常见前端反爬虫方式" class="headerlink" title="常见前端反爬虫方式"></a>常见前端反爬虫方式</h2><h3 id="检查浏览器user-agent"><a href="#检查浏览器user-agent" class="headerlink" title="检查浏览器user-agent"></a>检查浏览器user-agent</h3><p>通过检测当前user-agent是否为真实浏览器来区分当前请求是否来自真实用户。爬虫使用的常见user-agent类型：</p><ul><li>user-agent为空。没有设置user-agent。</li><li>user-agent中包含特殊字符。如：python,java,bot,spider, headless等。其中，使用chromedriver驱动无头浏览器<br>访问网站时，user-agent中会自动添加Headless字段。</li></ul><h3 id="检查浏览器是否有真实JS运行环境"><a href="#检查浏览器是否有真实JS运行环境" class="headerlink" title="检查浏览器是否有真实JS运行环境"></a>检查浏览器是否有真实JS运行环境</h3><p>常见方式： </p><ul><li>检查浏览器运行时对象。如<code>window, document, window.navigator, document.onmouseover,document.title, navigator.platform, window.location.href, history</code>等</li><li>检查浏览器功能。如: 操作cookie, 操作localStorage, 操作历史记录，操作iframe, 操作canvas, 操作window.performance</li></ul><h3 id="检查浏览器是否以无头模式运行"><a href="#检查浏览器是否以无头模式运行" class="headerlink" title="检查浏览器是否以无头模式运行"></a>检查浏览器是否以无头模式运行</h3><ul><li>检查调试器是否加载。如：将覆盖了toString方法的对象使用console.log输出到控制台，当控制台打开时，覆盖后的toString方法会被调用，可获取到控制台已被打开。</li></ul><p>以无头浏览器模式运行chrome时，会与真实浏览器存在差异。无头浏览器运行时差异主要有：</p><ul><li><code>window.chrome</code>不存在</li><li><code>navigator.plugins</code>为空。无任何浏览器插件是不正常的，正常情况会有一些默认的插件。</li><li><code>navigator.languages</code>为空。未设置浏览器当前语言环境。</li><li><code>navigator.webdriver</code>为true。chrome浏览器被chromdriver驱动时，这个值会设为true,正常应该为undefined</li><li>存在<code>document.$cdc_asdjflasutopfhvcZLmcfl_</code>。chromedriver 驱动的chrome浏览器，会设置一个这个属性。</li></ul><h3 id="图形验证码"><a href="#图形验证码" class="headerlink" title="图形验证码"></a>图形验证码</h3><p>不讨论这种情况。</p><h2 id="常见解决方法"><a href="#常见解决方法" class="headerlink" title="常见解决方法"></a>常见解决方法</h2><h3 id="后端检测了user-agent-解决：设置user-agent信息"><a href="#后端检测了user-agent-解决：设置user-agent信息" class="headerlink" title="后端检测了user-agent. 解决：设置user-agent信息"></a>后端检测了user-agent. 解决：设置user-agent信息</h3><p>以requests, httpx， scrapy访问网页时，设置user-agent信息.</p><pre><code class="python">    import requests    url = &#39;xx&#39;    session = requests.Session()    data = session.get(url, headers={&#39;User-Agent&#39;: &quot;xxxx&quot;}).json()</code></pre><h3 id="浏览器js检测了user-agent-解决方法：修改user-agent"><a href="#浏览器js检测了user-agent-解决方法：修改user-agent" class="headerlink" title="浏览器js检测了user-agent. 解决方法：修改user-agent"></a>浏览器js检测了user-agent. 解决方法：修改user-agent</h3><p>以chrome-driver浏览器运行时 删除user-agent中的headless字段。</p><pre><code class="python">    driver.execute_cdp_cmd(        &quot;Network.setUserAgentOverride&quot;,        {            &quot;userAgent&quot;: driver.execute_script(                &quot;return navigator.userAgent&quot;            ).replace(&quot;Headless&quot;, &quot;&quot;)        },    )</code></pre><h3 id="网页运行了一段js。-解决方法：JSV8运行页面js"><a href="#网页运行了一段js。-解决方法：JSV8运行页面js" class="headerlink" title="网页运行了一段js。 解决方法：JSV8运行页面js"></a>网页运行了一段js。 解决方法：JSV8运行页面js</h3><p>如果网页运行了一段混淆后js，计算出了一个token，访问时必须带着这个token, 可用JSV8运行网页js, 生成token.</p><h3 id="网页检测了window-chrome是否存在-解决方法：-设置window-chrome"><a href="#网页检测了window-chrome是否存在-解决方法：-设置window-chrome" class="headerlink" title="网页检测了window.chrome是否存在. 解决方法： 设置window.chrome"></a>网页检测了window.chrome是否存在. 解决方法： 设置window.chrome</h3><pre><code class="python">    driver.execute_cdp_cmd(        &quot;Page.addScriptToEvaluateOnNewDocument&quot;,        {            &quot;source&quot;: &quot;&quot;&quot;                Object.defineProperty(window, &#39;chrome&#39;, {                        get: () =&gt; {}                })&quot;&quot;&quot;        },    )</code></pre><h3 id="网页检测了navigator-webdriver是否为true-解决方法：-设置navigator-webdriver为undefined"><a href="#网页检测了navigator-webdriver是否为true-解决方法：-设置navigator-webdriver为undefined" class="headerlink" title="网页检测了navigator.webdriver是否为true. 解决方法： 设置navigator.webdriver为undefined"></a>网页检测了<code>navigator.webdriver</code>是否为<code>true</code>. 解决方法： 设置navigator.webdriver为undefined</h3><pre><code class="python">    driver.execute_cdp_cmd(        &quot;Page.addScriptToEvaluateOnNewDocument&quot;,        {            &quot;source&quot;: &quot;&quot;&quot;                Object.defineProperty(navigator, &#39;webdriver&#39;, {                        get: () =&gt; undefined                })&quot;&quot;&quot;        },    )</code></pre><h3 id="网页检测了navigator-plugins是否为空-解决方法：-设置navigator-plugins为自定义数据。"><a href="#网页检测了navigator-plugins是否为空-解决方法：-设置navigator-plugins为自定义数据。" class="headerlink" title="网页检测了navigator.plugins是否为空. 解决方法： 设置navigator.plugins为自定义数据。"></a>网页检测了<code>navigator.plugins</code>是否为空. 解决方法： 设置navigator.plugins为自定义数据。</h3><pre><code class="python">    driver.execute_cdp_cmd(        &quot;Page.addScriptToEvaluateOnNewDocument&quot;,        {            &quot;source&quot;: &quot;&quot;&quot;                Object.defineProperty(navigator, &#39;webdriver&#39;, {                        get: () =&gt; [1, 2, 3]                })&quot;&quot;&quot;        },    )</code></pre><h3 id="网页检测了navigator-languages是否为空-解决方法：-设置navigator-languages为自定义数据。"><a href="#网页检测了navigator-languages是否为空-解决方法：-设置navigator-languages为自定义数据。" class="headerlink" title="网页检测了navigator.languages是否为空. 解决方法： 设置navigator.languages为自定义数据。"></a>网页检测了<code>navigator.languages</code>是否为空. 解决方法： 设置navigator.languages为自定义数据。</h3><pre><code class="python">    driver.execute_cdp_cmd(        &quot;Page.addScriptToEvaluateOnNewDocument&quot;,        {            &quot;source&quot;: &quot;&quot;&quot;                Object.defineProperty(navigator, &#39;languages&#39;, {                        get: () =&gt; [&#39;en-US&#39;, &#39;en&#39;]                })&quot;&quot;&quot;        },    )</code></pre><h3 id="网页检测了Notification-permission是否为空-解决方法：-设置navigator-permission为自定义数据。"><a href="#网页检测了Notification-permission是否为空-解决方法：-设置navigator-permission为自定义数据。" class="headerlink" title="网页检测了Notification.permission是否为空. 解决方法： 设置navigator.permission为自定义数据。"></a>网页检测了<code>Notification.permission</code>是否为空. 解决方法： 设置navigator.permission为自定义数据。</h3><pre><code class="python">    driver.execute_cdp_cmd(        &quot;Page.addScriptToEvaluateOnNewDocument&quot;,        {            &quot;source&quot;: &quot;&quot;&quot;            Object.defineProperty(Notification, &#39;permission&#39;, { get: () =&gt; &quot;default&quot;});            &quot;&quot;&quot;        },    )</code></pre><h3 id="网页检测了-cdc-asdjflasutopfhvcZLmcfl-是否存在"><a href="#网页检测了-cdc-asdjflasutopfhvcZLmcfl-是否存在" class="headerlink" title="网页检测了$cdc_asdjflasutopfhvcZLmcfl_是否存在."></a>网页检测了<code>$cdc_asdjflasutopfhvcZLmcfl_</code>是否存在.</h3><p>需要修改<code>chromedriver</code>程序, 将<code>$cdc_asdjflasutopfhvcZLmcfl_</code> 替换为其他字符串。</p><pre><code class="shell">    sed -b -i &#39;s/$cdc_asdjflasutopfhvcZLmcfl_/$cda_asdjflasutopfhvcZLmcfl_/g&#39; /tmp/chromedriver</code></pre><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>如果遇到疯狂进行环境检测的网站，要绕过会非常恶心。这种情况最好的方式就是直接运行浏览器以无头模型进行爬取。</p><p>上面这些脚本和方法有人已经写了个库，<a href="https://github.com/ultrafunkamsterdam/undetected-chromedriver" target="_blank" rel="noopener">undetected-chromedriver</a>,使用这个库启动chrome就可以自动将无头浏览器的差异屏蔽掉。</p><p>但是这个只能开着浏览器界面运行，当以无头模式运行时，浏览器内部还是可以检测到chrome并没有在真实屏幕上运行。</p><p>解决方法：可以使用<code>pyvirtualdisplay</code>，将程序界面运行到虚拟屏幕上。此时也不需要弹出浏览器界面，在linux服务器上可以正常运行。</p><ul><li>安装依赖</li></ul><pre><code class="shell">    sudo apt-get install xvfb xserver-xephyr tigervnc-standalone-server x11-utils gnumeric    sudo apt install python3-virtualenv    virtualenv -p `which python3` venv    source venv/bin/active    pip3 install undetected-chromedriver    pip3 install pyvirtualdisplay pillow EasyProcess    python3 undetected_bot.py</code></pre><ul><li>示例代码</li></ul><pre><code class="python">    import time    import tempfile    import undetected_chromedriver.v2 as uc    from pyvirtualdisplay import Display    def main():        with Display(visible=False, size=(1366, 768), backend=&#39;xvfb&#39;) as _display:            options = uc.ChromeOptions()            options.add_argument(&#39;--user-data-dir={}&#39;.format(tempfile.mktemp()))            options.add_argument(&#39;--no-first-run --no-service-autorun --password-store=basic&#39;)            driver = uc.Chrome(version_main=98, options=options)            driver.get(&#39;http://javabin.cn/bot/bot.html?headless&#39;)            # time.sleep(8)            print(driver.find_element_by_tag_name(&#39;body&#39;).text)    if __name__ == &#39;__main__&#39;:        main()</code></pre><h2 id="cloudflare类似网页-检测点调试方法"><a href="#cloudflare类似网页-检测点调试方法" class="headerlink" title="cloudflare类似网页 检测点调试方法"></a>cloudflare类似网页 检测点调试方法</h2><ul><li>chrome F11, 在<code>Source</code>–&gt; <code>Event Listener BreakPoints--&gt;XHR</code>中，对<code>readystatechange</code>事件下断点。</li><li>刷新网页，待从后端拿到第二次 检测浏览器环境的js时，附近单步执行几步就会对加密js进行解密，拿到解密后的js.</li><li>复制出依赖的几个全局变量，window._cf_chl_opt， window._cf_chl_ctx 复制出第一次的js。</li><li>将上面这些变量和js存到 sources–&gt;Snippets 中。</li><li>格式化后对语法进行分析，可看出一个大的Switch case结构，而且所有的数据均是从<code>_</code>数组里取出。对switch下断点，单步调试就可。大部分都是对常规操作加了一些花指令，从<code>_</code>里解密出一堆字符串，然后用这些字符串计算一下，拼出要调用的真实函数名称和变量，再进行调用。</li></ul><h2 id="有用的一些链接和参考资料"><a href="#有用的一些链接和参考资料" class="headerlink" title="有用的一些链接和参考资料"></a>有用的一些链接和参考资料</h2><ul><li><a href="https://github.com/ycq0125/cloudflare_detection/tree/870e61abf5a43239afede6a7ceb41f22acdbfab7/detection" target="_blank" rel="noopener">cloudflare 监测点相关js 可阅读代码</a></li><li><a href="https://mp.weixin.qq.com/s/efloBirboVfH2hK3cNoU5A" target="_blank" rel="noopener">Cloudflare的分析流程</a></li><li><a href="https://mp.weixin.qq.com/s/Bv8v7kbjX5NWWzdwCnwFHg" target="_blank" rel="noopener">Cloudflare（5秒盾）分析！！</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们爬取cloudflare保护的网站时，网页会停留在跳转页面，然后运行一堆js来检测你的浏览器环境是不是真实用户访问，&lt;br&gt;如果检测不通过，就会一直卡在跳转页面，爬虫无法正常访问真实网页。如何解决？&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;爬虫检测网页[工具]&lt;/li&gt;
&lt;li&gt;常见前端反爬虫方式&lt;/li&gt;
&lt;li&gt;常见解决方法&lt;/li&gt;
&lt;li&gt;如何解决&lt;/li&gt;
&lt;li&gt;cloudflare调试方法&lt;/li&gt;
&lt;li&gt;有用的一些链接和参考资料
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="python" scheme="http://www.javabin.cn/tags/python/"/>
    
      <category term="爬虫" scheme="http://www.javabin.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>【智能音箱】小爱音箱pro拆机,刷机,开启ssh,备份系统的方法</title>
    <link href="http://www.javabin.cn/2021/xiaoai_fm.html"/>
    <id>http://www.javabin.cn/2021/xiaoai_fm.html</id>
    <published>2021-06-18T18:22:24.000Z</published>
    <updated>2024-03-11T14:49:03.614Z</updated>
    
    <content type="html"><![CDATA[<p>618买了一个小爱音箱（型号:lx06），发现预留了ttl接口也可以进入uboot，打算刷机折腾一下。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>拆机</li><li>获取管理员权限</li><li>uboot 刷机</li><li>系统内 刷机</li><li>系统备份</li><li>后续玩法探索<a id="more"></a></li></ul><h2 id="拆机"><a href="#拆机" class="headerlink" title="拆机"></a>拆机</h2><p>  小爱音箱pro底部有个软垫子，用细的起子别进去，然然后撕下来就可以看到螺丝孔。依次拆下螺丝，打开底盖。之后会看到电源线和AUX线在壳子上用四个螺丝固定着，拆下这四个螺丝即可分离壳子和内部主体部分。（注意螺丝别乱了，有三处不一样的螺丝：底座，电源线，电路板固定螺丝）<br>  底座拆开后：<br>  <img src="/photo_2021/xiaoai_base.jpg" alt="后盖图"></p><p>  内部电路板,图中标箭头的位置rx,tx,gnd即为ttl链接的触点，在电路板后面也有对应的rx, tx, gnd,在板子后面的这三个位置用电烙铁分别焊接一条杜邦线，准备链接usb转ttl模块(CH340模块)，进行调试。</p><p>  <img src="/photo_2021/xiaoai_board.jpg" alt="电路板"></p><h2 id="获取管理员权限"><a href="#获取管理员权限" class="headerlink" title="获取管理员权限"></a>获取管理员权限</h2><p>  使用nmap扫描音箱端口可以发现音箱只开启了53和9999端口，无法telnet或者ssh链接，所以只能使用ttl进行链接。<br>1、ubuntu安装putty<code>sudo apt install putty</code><br>2、链接usb转ttl模块(接线rx–&gt;rx, tx–&gt;tx, gnd–&gt;gnd)，电脑查询新增的COM端口设备 <code>ls /dev</code>，新增的一般在最后一个, 类似<code>/dev/ttyUSB0</code> 或者 <code>/dev/COM0</code><br>3、  启动putty 并设置链接类型为<code>serial</code>，设置tty端口速率为<code>115200</code>，设置端口为你本机的端口如<code>/dev/ttyUSB0</code>. 点击 open<br> <img src="/photo_2021/xiaoai_putty.png" alt="putty设置"><br>4、按下回车之后可看到linux 登录界面，输入用户名:root 后回车，由于旧版的系统没有密码，如果你的系统版本比较旧，会直接以root进入系统。<br>5、如果你的系统升级到了最新版，已经无法直接进入系统， 需要切换到另一个系统尝试（小爱音箱有两套系统，升级时会往另一套系统刷入固件，这样好处就是升级时断电的话，可以自动切换到另一个系统，下一次升级时，刷坏的系统会被重新刷机激活）。<br>6、切换系统的方法。链接上ttl，拔掉小爱电源并重新插上来重启小爱，此时ttl会输出大量启动日志，在重启时迅速按ctrl+c或者任意按键，会进入uboot. </p><ul><li>uboot 执行<code>printenv</code>可查看系统当前的环境变量，其中<code>boot_part</code>指定了当前启动的是哪个系统。</li><li>uboot 执行<code>setenv boot_part boot0</code>切换到另一个系统，如果你以前是boot1那就设置为boot0，反之以前是boot0就设置为boot1.</li><li>uboot 执行 <code>run bootcmd</code> 进入系统引导，此时会进入你设置的另一个系统<br>7、在新的系统尝试root无密码登录。如果不行，且系统没有提示<code>[magic][release]</code>字样，可以尝试使用计算的密码登录。密码计算方法:先将SN码和固定字符串拼接之后取md5, 然后前14位字符为密码。伪代码<code>md5(SN+SALT).hex().lower()[:14]</code>，其中SN为你机器的SN码，在机器底座上写着，一般为<code>XXXXX/A0XUXXXX</code>；SALT为一个固定的字符串，可以用<code>9C78089F-83C7-3CDC-BCC9-93B378868E7F</code> 或者 <code>B0168A6D-119A-F21A-DA58-980732F80A19</code> 试试。执行下面的语句也行，将SN处替换为你的SN编码.</li></ul><pre><code class="shell">python -c &#39;import hashlib;print(hashlib.md5(b&quot;SN&quot;+b&quot;B0168A6D-119A-F21A-DA58-980732F80A19&quot;).hexdigest()[:14])&#39;python -c &#39;import hashlib;print(hashlib.md5(b&quot;SN&quot;+b&quot;9C78089F-83C7-3CDC-BCC9-93B378868E7F&quot;).hexdigest()[:14])&#39;</code></pre><p>8、如果还是无法进入系统，尝试进入<code>failsafe</code>模式（小爱固件改自openwrt）。进入方法: 重启音箱，等一点时间(log会有提示 push f … failsafe)后连续按<code>f + enter</code>，此时会进入failsafe模式。</p><ul><li>查看当前固件布局<code>cat /proc/mtd</code>。可看到当前的固件中存在<code>system1 和sytem0</code></li><li>查看当前系统磁盘 <code>df -h</code>（system0 对应/dev/mtdblock4, sytem1对应/dev/mtdblock5）</li><li>挂载syetem0 <code>mount  /dev/mtdblock4 /mnt/sys1</code> ,直接执行<code>etc/mi_console</code>，会输出当前root用户的密码。或者查看 <code>etc/mi_console</code>文件中的SALT（密码生成逻辑在这个文件里，<code>/mnt/sys1/etc/init.d/boot_check</code>会调用<code>mi_console</code>生成密码）。执行<code>strings /mnt/sys1/bin/mi_console | grep -E &#39;^[A-Z0-9-]+$&#39;&#39;</code> 获得SALT，然后用上一步的计算方法计算密码，然后切换到对应系统进行登录，如果还是无法登录，可用试试这样操作另一个系统。</li></ul><p>9、如果还是无法登录系统或者无法进入failsafe模式，直接使用uboot刷写固件。</p><h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><h3 id="uboot刷机"><a href="#uboot刷机" class="headerlink" title="uboot刷机"></a>uboot刷机</h3><p>1、前提：需要准备一个系统镜像。方法：将当系统镜像通过uboot提供的<code>loady,loadx,loadb</code>命令从计算机传输到音箱系统指定的内存地址中，然后使用<code>nand earse</code>擦除 磁盘 分区，最后使用<code>nand write 将内存中的数据写入固定的磁盘地址中</code>。<br>2、准备系统镜像。</p><ul><li>可通过升级时抓包或者使用网上别人已经提供的系统升级文件分离出system.img。固件文件提取命令<code>binwalk -e xxx.bin</code></li><li>也可直接使用网上已经登录系统的用户，备份的自己的系统镜像。这里我直接使用网络上分享的备份系统，系统版本<code>1.66.8</code>。来源: <a href="https://bbs.hassbian.com/forum.php?mod=redirect&amp;goto=findpost&amp;ptid=8754&amp;pid=349732" target="_blank" rel="noopener">https://bbs.hassbian.com/forum.php?mod=redirect&amp;goto=findpost&amp;ptid=8754&amp;pid=349732</a>  感谢原作者提供的系统镜像。<br>3、修改系统固件。</li><li>解包系统: <code>sudo unsquashfs -dest m5 m5.img</code></li><li>设置ttl无密码登录: 修改<code>m5/etc/inittab</code> 文件，将<code>ttyS0::askfirst:/bin/login</code> 这一行改为 <code>ttyS0::askfirst:/bin/ash --login</code></li><li>重置系统密码: 准备修改<code>m5/etc/shadow</code>文件，将root密码替换为自己的密码。shadow文件中<code>:</code>分割的第二位为密码，格式为<code>$加密类型$SALT$加密的密码</code>，加密类型 1代表md5. 可使用openssl 生成, 执行<code>openssl passwd -1 -salt &#39;N0Iz0LLs&#39; &#39;reece++&#39;</code>生成 salt为<code>N0lz0LLs</code>,密码为<code>reece++</code>的加密后密码，将输出的字符串替换掉 <code>m5/etc/shadow</code>里<code>root:xxxx:</code>处的xxxx，改为<code>root:$1$N0Iz0LLs$EPqv7WOl5S7ub/.EppH73.:18128:0:99999:7:::</code>。如果不需要密码，可以直接留空，改为<code>root::0:99999:7:::</code>（建议设置密码，不然ssh链接不安全）。</li><li>设置开机启动脚本: 编辑<code>etc/rc.local</code>，在其中加入你准备开机执行的命令，此处可加入以下命令开启ssh。</li></ul><pre><code class="shell"># open ssh[ -d /data/dropbear ] || mkdir /data/dropbear[ -s /data/dropbear/rsa.key ] || dropbearkey -t rsa -s 1024 -f /data/dropbear/rsa.key &amp;&gt; /dev/null/usr/sbin/dropbear -E -P /var/run/dropbear.pid -r /data/dropbear/rsa.key &gt; /tmp/ssh.log# your script/data/user.sh</code></pre><p>含义: <code>/data/dropbear</code>文件夹不存在则创建, <code>/data/dropbear/rsa.key</code> 文件不存在则自动生成，然后启动dropbear 在默认22端口开启ssh 服务，最后执行<code>/data/user.sh</code>， 以后可编辑这个文件来加入自己的开机自启命令，不用修改系统（运行时系统是只读模式，只有data和tmp可写）</p><ul><li>禁止自动升级系统: 编辑<code>m5/etc/crontabs/root</code>,注释掉<code>* 3 * * * /bin/ota slient  # check ota</code>，也可以将执行<code>mv /bin/ota /usr/share/ota.bk</code>将升级程序移动到其他地方，防止远程执行升级。</li><li>重新打包系统: <code>sudo mksquashfs m5 m5_1.img -b 131072 -comp xz -no-xattrs</code><br>4、进入uboot,刷写固件。</li><li>查看固件分区布局，启动时输出的日志里会输出固件分区布局，如下所示:</li></ul><pre><code class="shell">Creating 6 MTD partitions on &quot;A revision NAND 1Gib TC5XXXXXXXXX&quot;:0x000000800000-0x000001000000 : &quot;tpl&quot;0x000001000000-0x000001600000 : &quot;boot0&quot;0x000001600000-0x000001c00000 : &quot;boot1&quot;0x000001c00000-0x000004400000 : &quot;system0&quot;0x000004400000-0x000006c20000 : &quot;system1&quot; NAND bbt detect factory Bad block at 60000000x000006c20000-0x000008000000 : &quot;data&quot;</code></pre><p>本次将刷入system0分区，当然你也可以刷入sytem1分区。</p><ul><li>将m5_1.img传输的windows下，电脑切换到windows系统，下载secureCRT, 或者其他支持 kermit, xmodem, ymodem,zmodem协议的终端链接软件。使用secureCRT链接对应com端口（可在设备管理中查看对应com端口），设置好传输速率115200和流控制XON/XOFF。重启小爱进入uboot.</li><li>uboot执行<code>loady 1c00000</code>准备将ymodem协议传输的文件写入内存地址1c00000</li><li>使用电脑secureCRT–菜单传输–菜单发送ymodem文件，添加刚才打包的镜像文件m5_1.img，开始传输。这个过程相当漫长，传输速率大概1-5kb/s，需要2个小时才能传输完。</li><li>传输完后, 开始擦除系统分区，根据刚才的固件分区布局可知，system0在<code>0x000001c00000-0x000004400000</code>地址范围内，先将该部分地址擦除为1（注意！注意！注意！！！请确认你的固件分区布局，不同设备可能不一致，如果你擦除了其他分区的数据，可能导致系统无法启动，请确认输入执行的地址正确。）执行 <code>nand earse 1c00000 2800000</code>，从1c00000地址处开始擦除2800000大小的空间，用结束地址减去开始地址就是分区大小。也可以执行<code>python -c &#39;print(&quot;%x&quot; % (0x4400000-0x1c00000,))&#39;</code>计算出分区大小。</li><li>写入固件到分区。执行<code>nand write 1c00000 1c00000 2800000</code>将内存1c00000处的数据写入磁盘1c00000处，写入大小2800000。</li><li>必须先擦除才能写入，<code>nand write</code>只能将1 变为0 不能将0变为1，所以需要先执行nand earse 将磁盘擦除为 0xff。如果你忘记擦除就写入，系统0启动时会由于squashfs 文件系统错误而无法启动，此时按以上流程刷重新写系统就行。</li><li>刷写成功之后，执行<code>setenv boot_part boot0</code>设置启动刚才刷写的系统0，然后执行<code>run bootcmd</code>加载系统。</li><li>如果刷写成功，ttl中直接按回车就可以进入系统，ssh服务也已经启动。</li></ul><p><img src="/photo_2021/xiaoai_nand.jpeg" alt="uboot"></p><h2 id="系统内刷机"><a href="#系统内刷机" class="headerlink" title="系统内刷机"></a>系统内刷机</h2><p>  如果你已经以root进入了系统，且链接上网络，可通过 dd 或者 mtd命令直接刷写系统。此处假设你已经进入system1,需要刷写system0.<br>  1.执行 <code>scp xxx@192.168.1.x:m5.img /tmp/m5.img</code>使用scp将系统镜像从ubuntu传输到音箱系统。其中xxx@192.168.1.x 替换为你ubuntu系统的用户名和ip地址，如果不能链接，可能是你ubuntu系统sshd服务配置有问题。<br>  2.执行 <code>mtd write /tmp/m5.img system0</code>将系统镜像写入system0分区内。<br>  3.执行<code>/usr/bin/fw_env -s boot_part boot0</code> 设置环境变量boot_part, 使重启时进入system0<br>  4.重启系统<code>reboot -f</code></p><p>第2步也可用<code>dd if=/tmp/m5.img of=/dev/mtdblock4</code>代替，不过<code>dd</code>无法跳过系统坏块，如果你的系统有坏块，将报错提示 io error。</p><h2 id="系统备份"><a href="#系统备份" class="headerlink" title="系统备份"></a>系统备份</h2><h3 id="备份系统分区的方法"><a href="#备份系统分区的方法" class="headerlink" title="备份系统分区的方法"></a>备份系统分区的方法</h3><p>将自己的各个分区备份，出问题后可通过uboot恢复。例如要备份系统0, mtdblock4:</p><ol><li>备份系统。<code>dd if=/dev/mtdblock4 of=/tmp/m4.img</code></li><li>传输到电脑 。<code>scp /tmp/m4.img xxx@192.168.1.x:m4.img</code></li><li>删除临时文件 <code>rm /tmp/m4.img</code></li></ol><p>如果当前分区有坏块，可拆分为多个文件，备份。</p><h3 id="备份data分区的方法"><a href="#备份data分区的方法" class="headerlink" title="备份data分区的方法"></a>备份data分区的方法</h3><p>在<code>电脑</code>linux系统里执行下面的命令即可将data分区(mtdblock6)备份到当前linux系统目录。其中将<code>192.168.1.192</code>换为你的小爱同学的ip地址。</p><pre><code class="shell">  ssh root@192.168.1.192  &quot;dd if=/dev/mtdblock6 | gzip -1 -&quot; | dd of=backup.gz</code></pre><p>文件已压缩，恢复时注意先用gzip解压缩</p><pre><code class="shell">  gzip -dk backup.gz</code></pre><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>  后续玩法探索<br> 1、替换唤醒词，自定义唤醒词<br> 2、拦截im消息，实现自定义命令</p><p> 声明：本文只作为技术研究，您如果使用以上内容用作其他用途，请自行承担后果，与本人无关。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;618买了一个小爱音箱（型号:lx06），发现预留了ttl接口也可以进入uboot，打算刷机折腾一下。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;拆机&lt;/li&gt;
&lt;li&gt;获取管理员权限&lt;/li&gt;
&lt;li&gt;uboot 刷机&lt;/li&gt;
&lt;li&gt;系统内 刷机&lt;/li&gt;
&lt;li&gt;系统备份&lt;/li&gt;
&lt;li&gt;后续玩法探索
    
    </summary>
    
    
      <category term="系统" scheme="http://www.javabin.cn/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="刷机" scheme="http://www.javabin.cn/tags/%E5%88%B7%E6%9C%BA/"/>
    
      <category term="小爱音箱" scheme="http://www.javabin.cn/tags/%E5%B0%8F%E7%88%B1%E9%9F%B3%E7%AE%B1/"/>
    
      <category term="智能家居" scheme="http://www.javabin.cn/tags/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/"/>
    
  </entry>
  
  <entry>
    <title>python单元测试中使用mock patch来解决不易测试的依赖</title>
    <link href="http://www.javabin.cn/2019/mock_patch.html"/>
    <id>http://www.javabin.cn/2019/mock_patch.html</id>
    <published>2019-12-04T13:15:11.000Z</published>
    <updated>2024-03-11T14:49:03.607Z</updated>
    
    <content type="html"><![CDATA[<p>在进行单元测试时，有时会遇到代码里有大量 的外部接口请求，异步逻辑，复杂的校验，无法进行单元测试的函数调用等情况。这时，可使用mock工具来对这些逻辑进行patch。</p><a id="more"></a><h2 id="待测逻辑中有异步调用"><a href="#待测逻辑中有异步调用" class="headerlink" title="待测逻辑中有异步调用"></a>待测逻辑中有异步调用</h2><p>对异步调用的逻辑进行patch，使非异步调用逻辑可以正常执行。在当前单元测试中只校验异步调用时传入的参数正确。然后对异步调用的函数单独编写单元测试即可。</p><p>示例:</p><pre><code class="python"># coding: utf-8&quot;&quot;&quot;tasks/task.py简单模拟一个异步任务&quot;&quot;&quot;import threadingimport timeclass Task(object):    def __init__(self, val):        self.val = val    def run(self):        raise NotImplementedError    def apply(self):        self.run()    def apply_async(self):        thread = threading.Thread(target=self.run)        thread.start()class AddTask(Task):    def run(self):        print(&quot;running&quot;)        time.sleep(10)  # 耗时任务        self.val *= 30if __name__ == &quot;__main__&quot;:    print(AddTask(12).apply_async())    print(123)</code></pre><p>编写单元测试,patch异步调用</p><pre><code class="python"># coding: utf-8&quot;&quot;&quot;tests/tests.py&quot;&quot;&quot;from unittest import TestCasefrom mock import patchfrom tasks.task import func, AddTaskclass TestTask(TestCase):    @patch(&quot;tasks.task.AddTask&quot;)    # patch addtask    def test_task(self, mocked_task):        a = 1        b = 2        func(a, b)        mocked_task.assert_called_once_with(a+b)  # 只判断调用时参数正确    def test_add_task(self):        x = 10        task = AddTask(x)        task.apply()        assert x * 30 == task.val</code></pre><h2 id="待测逻辑中有无法单元测试的逻辑"><a href="#待测逻辑中有无法单元测试的逻辑" class="headerlink" title="待测逻辑中有无法单元测试的逻辑"></a>待测逻辑中有无法单元测试的逻辑</h2><p>对于待测逻辑中存在依赖外部接口，进行参数校验等逻辑，可进行patch,忽略这些校验使测试继续进行。</p><pre><code class="python"># tasks/task.pydef trans_name(name, val):  # 模拟一个简单场景:调用api校验数据后，然后才进行一系列逻辑    data = requests.get(u&quot;http://123.com/api/v2/check_name?name={}&quot;.format(name)).json()    if data[&#39;status&#39;] == &#39;ok&#39;:        name = &quot;{}_{}&quot;.format(name, val)        return name    return None</code></pre><p>编写单元测试，<code>patch requests.get</code>返回值和<code>json</code>方法</p><pre><code class="python"># coding: utf-8&quot;&quot;&quot;tests/test_process.py对于待测逻辑中存在依赖外部接口，进行参数校验等逻辑，可进行patch,忽略这些校验使测试继续进行。&quot;&quot;&quot;from unittest import TestCasefrom mock import patch, Mockfrom tasks.task import trans_nameclass TestTask(TestCase):    @patch(&quot;tasks.task.requests&quot;)    # patch addtask    def test_trans_name(self, mocked_requests):        name = &quot;ccc&quot;        val = &quot;222&quot;        mocked_response = Mock()        mocked_response.status_code = 200        mocked_response.json.return_value = {            &quot;status&quot;: &quot;ok&quot;        }        mocked_requests.get.side_effect = [mocked_response]        self.assertEqual(&quot;{}_{}&quot;.format(name, val), trans_name(name, val))        assert mocked_requests.get.call_count == 1</code></pre><h2 id="有多个patch对象"><a href="#有多个patch对象" class="headerlink" title="有多个patch对象"></a>有多个patch对象</h2><p>多个patch对象的参数顺序如下示例所示:</p><pre><code class="python">    @patch(&quot;tasks.task.AddTask1&quot;)    @patch(&quot;tasks.task.AddTask2&quot;)    def test_add_task(self, AddTask2, AddTask1):        pass</code></pre><h2 id="修改函数功能"><a href="#修改函数功能" class="headerlink" title="修改函数功能"></a>修改函数功能</h2><p>可将函数替换为自己定义的函数，实现修改函数的执行效果。这里为了简单说明情况，以替换time.sleep函数来说明情况。</p><pre><code class="python">@patch(&quot;tasks.task.time&quot;)    def test_func(self, mocked_time):        def sleep(t):   # 修改函数功能，以time.sleep举例            if t &gt; 3:                time.sleep(3)            else:                time.sleep(t)        mocked_time.sleep = Mock(side_effect=sleep)        func(3, 2)</code></pre><h2 id="替换函数返回值"><a href="#替换函数返回值" class="headerlink" title="替换函数返回值"></a>替换函数返回值</h2><p>直接改变函数返回值，用于patch token校验类的逻辑</p><pre><code class="python">@patch(&quot;tasks.task.token_check&quot;, return_value=True)    def test_func_ret(self, mocked_token_check):        pass</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行单元测试时，有时会遇到代码里有大量 的外部接口请求，异步逻辑，复杂的校验，无法进行单元测试的函数调用等情况。这时，可使用mock工具来对这些逻辑进行patch。&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="python" scheme="http://www.javabin.cn/tags/python/"/>
    
      <category term="单元测试" scheme="http://www.javabin.cn/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>由数据不一致引起的对事物处理，事物可见性和session缓存的思考</title>
    <link href="http://www.javabin.cn/2019/sqlalchemy_session.html"/>
    <id>http://www.javabin.cn/2019/sqlalchemy_session.html</id>
    <published>2019-12-03T14:39:11.000Z</published>
    <updated>2024-03-11T14:49:03.612Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个问题：使用<code>sqlalchemy</code>创建了两个session,然后在第一个session里创建了一条数据，并commit到数据库后，在第二个session中修改了这条数据并commit到数据库，接着回到第一个session中查询,查询到的竟然是没有修改之前的数据。<br><a id="more"></a></p><h2 id="猜测原因"><a href="#猜测原因" class="headerlink" title="猜测原因"></a>猜测原因</h2><p>刚开始猜测到了两种原因：session缓存，事物可见性。这里一一说一下每种的分析。</p><h3 id="猜测是事物可见性导致的"><a href="#猜测是事物可见性导致的" class="headerlink" title="猜测是事物可见性导致的"></a>猜测是事物可见性导致的</h3><p>由于关闭了<code>auto commit</code>，采用手动显示提交事物的方式。猜测第一个session中的查询处于事物中，导致无法看到另一个session中事物对数据库做出的修改。</p><p>调试方法:<br>1.单步debug后发现的确是第一个session在最后一次查询时，查询到的结果和数据库不一致。第二个session的修改内容没有在这里体现。<br>2.对第一个session中创建对象并commit之后的<code>session</code>对象调试，发现它的<code>transaction</code>属性的状态为<code>ACTIVE</code><br>3.继续进入源码调试发现<code>transaction</code>状态在提交后会变为CLOSED然后又会重新开始一个事物。也就是说<code>第二个session修改数据时，第一个session也处于事物中</code>。</p><pre><code class="python">    # transaction的close方法中将自己的状态置为CLOSED,然后又开始一个事物。     def close(self, invalidate=False):        self.session.transaction = self._parent        if self._parent is None:            for connection, transaction, autoclose in set(                self._connections.values()            ):                if invalidate:                    connection.invalidate()                if autoclose:                    connection.close()                else:                    transaction.close()        self._state = CLOSED        self.session.dispatch.after_transaction_end(self.session, self)        if self._parent is None:            if not self.session.autocommit:                self.session.begin()        self.session = None        self._connections = None</code></pre><p>4.但是第二个session的事物明明已经提交了，在处于默认的事物级别（读已提交READ_COMMITED）下按理第一个session是可以读到修改的数据的。但是还是尝试下是否可以解决问题。即查询前提交或者放弃一次事物。</p><p>解决方法：<br>在查询之前调用一次<code>session.commit()</code>或者<code>session.rollback()</code>即可，也<code>的确管用</code>。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>sqlalchemy</code>如果关闭<code>auto commit</code>的话，事物的管理是这样的：如果前一个事物被提交后，会将当前事物关闭，然后 马上重新开启一个事物。也就是说，你每时每刻都处于一个事物里，这会由于事物隔离级别导致不同事物间可能无法查询到写入数据库的数据。</p><p>但是目前这个场景却不是事物可见性导致的情况。因为第二个session 的事物已经提交，READ_COMMITED事物隔离级别下，这时数据库里的数据谁都可以查到的。（pgsql数据库查询默认事物隔离级别:<code>show default_transaction_isolation;</code>查看当前事物隔离级别:<code>show transaction_isolation;</code>）</p><h2 id="session-缓存"><a href="#session-缓存" class="headerlink" title="session 缓存"></a>session 缓存</h2><p>ORM框架建立了对象和数据库表之间的映射关系，当然也需要维护这个关系。一般都会实现持久化对象状态的维护(分别标记：未持久化的对象，已持久化到数据库的对象，已从数据库中删除的对象,已脱离session的对象等) <code>sqlalchemy</code>的状态可以查看文档:<a href="https://docs.sqlalchemy.org/en/13/orm/session_state_management.html" target="_blank" rel="noopener">持久化状态</a>)，而且也实现了session级的对象缓存，比如查询一个对象两次，第二次发现这个对象是已经持久化到数据库的对象，就不走数据库，直接从session缓存里取。这也就导致了，如果有两个session，那么每个session都不会知道自己从数据库里获取的对象已经被修改了，这时再从缓存中取的话，就会取出已经过期的数据。（一般以事物级别维护，同一个事物内才会如此）</p><h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><p>1.直接调用<code>session.expire(obj)</code>使当前对象过期后，查询数据库发现<code>查询结果和数据库一致</code>。<br>2.尝试打开<code>sqlalchemy</code>的<code>query log</code>. 在<code>create_engine</code>时设置<code>echo=True</code></p><pre><code class="python">    engine = create_engine(&quot;db_url&quot;, echo=True)</code></pre><p>发现有查询日志。</p><p>3.在我的场景里，第一个session创建的是B对象且已经提交。第二个session实际修改的是对象A的关联对象 对象B的字段。debug一下，在第一个session查询对象A之后，尝试读出对象B和B的属性时。下断点。可以F7跟进时看到进入了下面的代码。</p><pre><code class="python">    class InstrumentedAttribute(QueryableAttribute):        &quot;&quot;&quot;Class bound instrumented attribute which adds basic        :term:`descriptor` methods.        See :class:`.QueryableAttribute` for a description of most features.        &quot;&quot;&quot;        def __set__(self, instance, value):            self.impl.set(                instance_state(instance), instance_dict(instance), value, None            )        def __delete__(self, instance):            self.impl.delete(instance_state(instance), instance_dict(instance))        def __get__(self, instance, owner):            if instance is None:                return self            dict_ = instance_dict(instance)            if self._supports_population and self.key in dict_:                return dict_[self.key]            else:                return self.impl.get(instance_state(instance), dict_)</code></pre><p>其中 <code>__get__</code>方法即为获取属性时调用的方法，获取B对象的属性时，发现传入的B对象的地址和第一个session初次创建的对象B的地址一致，直接是同一个对象。的确是缓存导致了数据不一致的情况。</p><p>4.继续测试发现在新的事物中，读取上一个事物中已经commit的对象B的属性，会导致如果从当前事物中查询和这个对象B一样的query，就会直接使用对象B的缓存。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>查询前<code>session.expire(obj)</code>，<code>session.refresh(obj)</code>或者<code>session.commit()</code>，<code>sessoion.rollback()</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>sqlalchemy</code>关闭<code>auto commit</code>。就算commit后也其实一直在一个事物中</li><li>多个事物修改查询同一个数据，事物隔离级别和查询时机会影响查询的结果。</li><li>session缓存会出现拿到过期数据。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到一个问题：使用&lt;code&gt;sqlalchemy&lt;/code&gt;创建了两个session,然后在第一个session里创建了一条数据，并commit到数据库后，在第二个session中修改了这条数据并commit到数据库，接着回到第一个session中查询,查询到的竟然是没有修改之前的数据。&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据库" scheme="http://www.javabin.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事物" scheme="http://www.javabin.cn/tags/%E4%BA%8B%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>Python性能优化浅谈</title>
    <link href="http://www.javabin.cn/2019/python_profile.html"/>
    <id>http://www.javabin.cn/2019/python_profile.html</id>
    <published>2019-11-28T13:39:11.000Z</published>
    <updated>2024-03-11T14:49:03.610Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一些性能优化方面的事情，总结一下遇到的一些问题和解决方法。<br><a id="more"></a></p><h2 id="优化哪里？"><a href="#优化哪里？" class="headerlink" title="优化哪里？"></a>优化哪里？</h2><p>既然需要性能优化，肯定是程序运行缓慢，那首先需要知道的是<code>慢在哪里</code>？<code>从哪里开始优化</code>?下面分情况说一下这个问题。</p><h3 id="系统那一部分运行缓慢"><a href="#系统那一部分运行缓慢" class="headerlink" title="系统那一部分运行缓慢?"></a>系统那一部分运行缓慢?</h3><p>对于分布式或者大型系统，由于子模块较多，组件较多，某一部分的运行缓慢可能会导致整个系统的运行缓慢。定位子模块，组件的方法很简单，只需要分别对每个部分进行benchmark,统计出每个部分的运行时间即可。常用的方法有：</p><ul><li><p>1.最简单的，直接使用，调用，运行单独的部分，统计运行时间。</p><ul><li>如:检查接口缓慢时。可先检查网络是否正常<code>ping  myserver.com</code> ，然后检查nginx是否正常<code>time curl -IL http://www.myserver.com/1.png</code> 接着检查web 服务是否缓慢  <code>time curl -IL http://www.myserver.com/api/v1/2</code>  </li></ul></li><li><p>2.在应用中添加统计运行时间的日志。</p><ul><li>如配置<code>logging</code>,或者开启服务的<code>慢查询日志</code>。</li></ul></li><li>3.借助相关工具查看性能差异。<ul><li>如:<code>top,htop</code>查看系统负载。<code>redis-benchmark，memaslap</code>等测试服务性能。</li></ul></li></ul><h3 id="Python程序缓慢如何定位"><a href="#Python程序缓慢如何定位" class="headerlink" title="Python程序缓慢如何定位"></a>Python程序缓慢如何定位</h3><ul><li>1.程序不是我写的,源码丢失。<ul><li>将pyc反编译为py。借助<code>uncompile2</code>工具反编译。记得<code>IDA 反编译工具</code>也可以，具体我没有试过，可以研究下。</li><li>使用<code>strace</code>  加载运行的进程，然后尝试触发缓慢的操作，接着将日志dump出来。可通过对日志中的系统调用时间进行分析，来确认那一部分缓慢，一般需要这样操作的情况，很大可能需要关注<code>socket</code>的 <code>recv send</code> 调用或者对<code>mutex_lock</code>锁的请求。</li></ul></li><li>2.有源码，但是只能线上运行或者只能线上重现。<ul><li><code>strace</code> 加载运行的进程</li><li>加日志分析统计运行缓慢的地方</li><li>使用pickle保存要调试函数的运行时的依赖参数对象，然后载入这些参数后进行正常情况的分析。</li></ul></li><li>3.正常情况<ul><li>使用<code>cprofile,line_profiler,vprof,yappi_profiler</code>之类的工具分析程序中各个函数的调用次数和时间</li><li>使用<code>Pycham</code>自带的<code>profile</code>工具，直接run菜单点击<code>Profile &#39;xxx.py&#39;</code>即可。自带的工具支持<code>call graph</code>模式查看耗时情况，非常直观。</li></ul></li></ul><h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><h3 id="Python中一般优化方法"><a href="#Python中一般优化方法" class="headerlink" title="Python中一般优化方法"></a>Python中一般优化方法</h3><ul><li>1.低风险高收益的情况。优化调用次数高的 util 方法，公共方法，多重迭代中调用的方法。 </li><li>2.高风险的情况。优化（重构）指定复杂函数的实现，优化拥有大量逻辑的方法，优化不熟悉的逻辑，改变函数功能。</li></ul><h3 id="开始优化"><a href="#开始优化" class="headerlink" title="开始优化"></a>开始优化</h3><ul><li>1.尝试去掉无用的<code>deepcopy</code>,<code>deepcopy</code>中为了检测相互引用，性能损失非常大。干掉deepcopy的方法如下:<ul><li>使用浅拷贝或者赋值。分析逻辑，如果deepcopy的结果只是修改了1,2层，直接使用copy,或者列表推导式重新生成一个修改后的结果。</li><li>使用其他序列化方法。如果只是字典，可<code>json.loads(json.dumps(x))</code>，注意:这种操作会导致<code>int类型的key被转换为字符串</code>，如果无法接受，请不要采取这种方法。</li></ul></li><li>3.将正则表达式提前编译<ul><li>当被大量调用时，<code>re.search(r&#39;xc+&#39;, &#39;xxxccxx&#39;)</code>要比先一次<code>p=re.compile(r&#39;xc+&#39;)</code>之后再<code>p.search(&#39;xxxccxx&#39;)</code>慢很多。原因是正则表达使用时如果没有编译的话，会先进行编译，然后缓存下来，但是这个缓存很小，先编译并自行保存起来将可以有效提升速度。</li></ul></li><li>4.使用C库替换py库，如使用<code>cPickle替换pickle</code>。</li><li>5.去掉不需要的迭代。如使用<code>(x for x in c if x.id==1)替代[x for x in c if x.id==1]</code>，使用<code>xrange替代range</code></li><li>6.去掉无用的逻辑。如 <code>while len(x) &gt; idx</code>先计算出<code>cnt = len(x) 然后在while cnt &gt; idx</code></li><li>7.将无参数依赖的函数或者功能，转为类变量或者cached_property。</li><li>8.去重时在set中判断 而不是 list.</li><li>9.对于重复遍历的数据。先以id或者其他label建立mapping，减少遍历次数。</li><li>10.对于可缓存参数的函数。添加<code>function_tools.lru_cache</code>或者 <code>pyhon2.7</code>里的<code>backports.functools_lru_cache.lru_cache</code>或者对于逻辑不复杂的，直接建立<code>mapping</code>全局变量保存</li><li>11.预生成结果。对于参数规模可以预测的，预先生成全局mapping即可。</li><li>12.减少数据库操作。迭代执行sql的操作，转换为一条语句执行，或批量执行。</li><li>13.尝试将串行转并行<ul><li>对于执行结果无依赖的逻辑,可串行执行。如使用子进程生成结果时，如果生成的结果在当前函数里不在读取，可直接执行子进程，然后在函数末尾等待进程结束。</li></ul></li><li>14.对于IO密集型的程序（大量时间在等待IO），使用多线程，简单实现可直接使用线程池<code>multiprocessing.dummy.Pool</code>.</li><li>15.对于计算密集型程序（大量时间是执行算法逻辑），使用低级语言，多任务，分布式，异步任务和消息队列，高性能计算。如<code>Cpython实现,numpy,cpickle</code>,<code>multiprocessing</code>，<code>celery+rabbitmq+GFS</code>, <code>numba</code>。</li><li>16.对于web程序,使用异步IO。如添加<code>gevent</code>支持，使用<code>tornado web框架</code>, 使用<code>python3 await/async</code>新特性。</li><li>17.对于网络接口添加缓存。如使用内存数据库<code>memcache</code>, 可持久化内存数据库<code>redis</code>,mmap类数据库<code>mongo</code>等缓存服务。</li><li>18.建立本地缓存。如在前端使用<code>localstorage</code>缓存接口数据，安卓使用<code>sqlite</code>缓存离线数据。</li><li>19.页面静态化。如将页面分块后转为静态文件，以前只在java web项目中见到过。</li><li>20.升级硬件，网络，增加CDN服务。有钱可以优先考虑这个。</li></ul><h2 id="优化后如何保持"><a href="#优化后如何保持" class="headerlink" title="优化后如何保持"></a>优化后如何保持</h2><ul><li>使用<code>pylint</code>等工具做静态代码检查，并加入持续集成。</li><li>进行<code>code review</code></li><li>使用<code>ngios，zabbix</code>等做监控，加入性能监控脚本，业务中使用<code>statsd, logging</code>加入<code>benchmark</code>检测埋点，持续监控<code>slow query</code>,<code>slow log</code>。</li><li>进行 单元/API测试（保证代码 可单元测试）</li><li>对单一服务进行benchmark测试。</li><li>升级硬件</li></ul><h2 id="性能与实现简单之间的平衡"><a href="#性能与实现简单之间的平衡" class="headerlink" title="性能与实现简单之间的平衡"></a>性能与实现简单之间的平衡</h2><ul><li>先做低风险高收益优化</li><li>可以升级硬件解决的也不是啥大问题</li><li>太复杂必然会带入bug</li><li>做好充足测试</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做一些性能优化方面的事情，总结一下遇到的一些问题和解决方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="性能优化" scheme="http://www.javabin.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>pgsql中的日期处理</title>
    <link href="http://www.javabin.cn/2019/sql_date.html"/>
    <id>http://www.javabin.cn/2019/sql_date.html</id>
    <published>2019-10-06T15:10:54.000Z</published>
    <updated>2024-03-11T14:49:03.612Z</updated>
    
    <content type="html"><![CDATA[<p>总结下数据库中的日期处理<a id="more"></a></p><ul><li>字符串日期转时间: <code>select &#39;20190202&#39;::DATE;</code> 或 <code>select DATE(&#39;20190202&#39;);</code></li><li>当前日期: <code>select CURRENT_DATE</code></li><li>按月/月初:<code>select DATE_TRUNC(&#39;month&#39;, &#39;20191111&#39;::DATE);</code> 或 <code>select substr(&#39;20191111&#39;, 0,7);</code></li><li>按年/年初:<code>select DATE_TRUNC(&#39;year&#39;, &#39;20191111&#39;::DATE);</code> 或 <code>select substr(&#39;20191111&#39;, 0,5);</code></li><li>按季度/季初:<code>select DATE_TRUNC(&#39;quarter&#39;, &#39;20191111&#39;::DATE);</code></li><li>月末:(加一个周期后减一天)<code>select DATE_TRUNC(&#39;month&#39;, &#39;20190211&#39;::DATE)+INTERVAL &#39;1&#39; MONTH - INTERVAL &#39;1&#39; DAY;</code></li><li>年末:<code>select DATE_TRUNC(&#39;year&#39;, &#39;20190211&#39;::DATE)+INTERVAL &#39;1&#39; YEAR - INTERVAL &#39;1&#39; DAY;</code></li><li>季末:<code>select DATE_TRUNC(&#39;quarter&#39;, &#39;20190211&#39;::DATE)+INTERVAL &#39;3&#39; month - INTERVAL &#39;1&#39; DAY;</code></li><li>取表中最后一天/最后一次更新的数据作为最终数据。在每日报表，每日更新表中，取最后一天的数据作为统计使用的数据: <ul><li>创建测试表，学生每日测试成绩表，每位学生的数据每日更新一次:<code>create table student_score (id int, name varchar(25), score int, t varchar(12))</code></li><li>创建测试数据: <code>insert into student_score select generate_series(1,100) as key, (random()*(10^3))::text, (random()*100)::int, CURRENT_DATE + (random()*100)::int - 50;</code></li><li>测试语句，取最后一天的数据作为最终数据:<code>with time_end as (select t from student_score order by t desc limit 1) select name, score from student_score where t=(select *from time_end);</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结下数据库中的日期处理
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="数据库" scheme="http://www.javabin.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="pgsql" scheme="http://www.javabin.cn/tags/pgsql/"/>
    
      <category term="sql" scheme="http://www.javabin.cn/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch中如何依据字符串长度过滤</title>
    <link href="http://www.javabin.cn/2019/elastic_search_size.html"/>
    <id>http://www.javabin.cn/2019/elastic_search_size.html</id>
    <published>2019-09-23T13:11:24.000Z</published>
    <updated>2024-03-11T14:49:03.596Z</updated>
    
    <content type="html"><![CDATA[<p>使用elasticsearch时，如何实现查找 name字段长度大于15的文档？这种类似的需求？</p><a id="more"></a><h2 id="解决方法1-使用regexp"><a href="#解决方法1-使用regexp" class="headerlink" title="解决方法1 使用regexp"></a>解决方法1 使用<code>regexp</code></h2><p>直接使用正则查询，不用修改原始的mapping，直接就可以查询，但是查询效率不高，适合数据量小的项目。</p><pre><code class="python">    es.search(index=&#39;test&#39;, body={        &#39;query&#39;:{            &#39;bool&#39;:{                &#39;filter&#39;:{                    {                             &#39;regexp&#39;: {                                 &#39;name&#39;: {                                     &#39;value&#39;: &#39;.{15,}&#39;                                 }                             }                         }                }            }        }    })</code></pre><h2 id="解决方法二-使用script脚本"><a href="#解决方法二-使用script脚本" class="headerlink" title="解决方法二 使用script脚本"></a>解决方法二 使用script脚本</h2><p>这种只能支持keyword类型字段。</p><pre><code class="python">    es.search(index=&#39;test&#39;,body={    &#39;query&#39;:{        &#39;bool&#39;:{            &#39;filter&#39;:{                &#39;script&#39;:{                    &#39;script&#39;:{                        &#39;inline&#39;: &quot;doc[&#39;name&#39;].length&gt;15&quot;,                        &#39;lang&#39;:&#39;painless&#39;                        }                    }                }            }        },    &#39;from&#39;:0,     &#39;size&#39;:20    })</code></pre><h2 id="解决方法三-创建新字段"><a href="#解决方法三-创建新字段" class="headerlink" title="解决方法三 创建新字段"></a>解决方法三 创建新字段</h2><p>创建新字段记录数据长度。查询快但是需要在数据更新时维护该字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用elasticsearch时，如何实现查找 name字段长度大于15的文档？这种类似的需求？&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="elasticsearch" scheme="http://www.javabin.cn/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>蓝天，白云，雪山，草原，4700m高山湖泊--记稻城亚丁5日游</title>
    <link href="http://www.javabin.cn/2019/daochengyadinng.html"/>
    <id>http://www.javabin.cn/2019/daochengyadinng.html</id>
    <published>2019-09-06T12:00:24.000Z</published>
    <updated>2024-03-11T14:49:03.593Z</updated>
    
    <content type="html"><![CDATA[<p>想去稻城亚丁的想法在TODO 清单里躺了很久，这次终于安排上。和最爱的人来到了这个‘蓝色星球上的最后一片净土’，看到了最美的风景，当然也感受到了高海拔缺氧带来的痛苦。</p><p>读完本篇将知道：</p><ul><li>第一视角的稻城亚丁跟团游行程</li><li>如何安排行程，行程前准备，旅行中看啥美景，吃啥美食，以及可能的消费</li><li>如何避免被坑，哪些地方有坑</li><li>如何第一次跟团游</li><li>如何减弱高原反应（的痛苦）</li></ul><a id="more"></a><h2 id="行程安排"><a href="#行程安排" class="headerlink" title="行程安排"></a>行程安排</h2><ul><li>出行方式：跟团游，汽车，在飞猪上评价最高的那些旅行团里选就行。选舒适大巴就可以，上次去青海湖是小团包车，反而感觉不自由。我感觉大团和小团都没有强制购物，都会有推销性质的自愿购物，但是大团反而更自由一些（可以安心睡觉，安心干自己的事情，不用被人打扰）。</li><li>其他出行方式：飞机。由于稻城机场海拔较高，直接飞过去高原反应据说还是比较猛烈的，而且机票单程1000-4000多。所以，汽车还是相当稳的出行方式。</li><li>景点行程安排：<ul><li>第一天：成都–泸定桥–折多山–新都桥（月份不对，8月这个地方没有景，得秋天去）–住新都桥（可以看到贡嘎雪山，去镇上补充物资）</li><li>第二天：新都桥–318川藏线–兔子山–毛亚大草原–红草地–海子山–稻城白塔（这里会有医疗服务站的人上车宣传，售卖高纯度医用氧气罐，买它！一个人大概2-3瓶。不用买推销的另一个保健品。）–住香格里拉</li><li>第三天：香格里拉–冲古寺（可以看到仙乃日雪山）–洛绒牛场–牛奶海–五色海（得天气晴了去，秋天最好）–住香格里拉。</li><li>第四天：再次去稻城亚丁景区，走短线看仙乃日雪山或者不去了直接去其他地方。第四天开始跟团游就比较坑了，由于大家都扛不住高反，就没有再次去稻城亚丁景区，直接去了这两个地方：藏民家中（会去藏民家里吃一顿饭，然后参观一下藏民的风俗文化，有免费讲解，但是会推销银器，自愿购买。银器19.8一克。）—一个经堂（参观一些古建筑，会有一个自愿捐经幡祈福的环节，一个20，一套100）。</li><li>第五天：不去看沿途景色直接走高速，半天就回成都了。一直在睡觉，偶尔导游会推销一些土特产啥的，味道还行。</li></ul></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>钱：大概每人共需要2200左右</li><li>高反药物：注意是药物，那些红景天，xx安之类的保健品估计没啥用。需要的是：<ul><li>头痛药：散利痛（买它，效果非常好，而且是OTC，药店都可以买到。用这个加充足的氧气瓶，你可以登顶海拔4700m五色海了。没这个东西，可以让你知道啥叫“头痛欲裂”）； 布洛芬：速效退热，治头痛的。（OTC。第一个效果太好，导致第二个没有用到）</li></ul></li><li>保暖的衣服：上衣：轻羽绒，冲锋衣+一件短袖；裤子：运动裤之类长裤。高海拔比较冷，成都又比较热，所以里面一件可以外穿的薄衣服，外面一件方便换衣的厚的就行。 （感冒了高反会很大机率变为肺水肿，会死人的，而且必须马上离开高原，所以切记不要感冒。）</li><li>便携式血氧仪：可以立马测出血氧含量和心跳，京东有售。血氧平原正常是96%，到高原是85%，到稻城亚丁稍微一运动会掉到70%左右（爬山时间太长，会掉到70%以下，心跳近150，这时候不要死撑，顶不住，马上休息+吸医用氧）。低于90%太久就开始头痛了，通过主动调整呼吸或者吸氧可以弥补；低于80%，马上停下休息+吸氧。低于70%24小时得不到恢复就会GG。</li><li>氧气瓶：过了泸定桥之后旅行团会送一个运动氧，足够用到第二天下午。注意到 折多山之后就开始调整呼吸的幅度，主动呼吸。在稻城的医疗站会有医用氧，纯度高，用的时间长。一个人需要2-3瓶。</li><li>安奈晒spf50++：高原紫外线强，不想被晒蜕皮就用它。</li><li>充气靠枕+眼罩：旅行团会送一套，但是太垃圾，基本都会漏气。由于大量时间在乘坐汽车，这个东西是神器。</li><li>雨伞，雨衣。高原天气阴晴不定，一般都会有下雨的地方。</li><li>高热量食物：士力架，巧克力，红牛。葡萄糖冲剂（高反了可以喝这个直接补充葡萄糖，效果不错）</li><li>还有一些：非OTC的药，可以治疗高原反应的。但是都有过敏成分，也不好购买。所以就不推荐了。</li><li>心里准备：稻城亚丁海拔较高，网上之说了这地方多好看，但是没说这地方必然会下雨，所以只能祈祷不是你去的那段时间下雨了。</li></ul><h2 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h2><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="泸定桥"><a href="#泸定桥" class="headerlink" title="泸定桥"></a>泸定桥</h3><p>行程的第一站，小学课本上学过的飞夺泸定桥，说的就是这里。建在大渡河上，整个桥都是一个个铁索连起来，中间铺了一些木板，左右缝隙比较大，桥恍得厉害。。。上桥感受一次门票10元。</p><p><img src="/photo_2019/ludingqiao.jpg" alt=""></p><h3 id="318川臧线-amp-折多山"><a href="#318川臧线-amp-折多山" class="headerlink" title="318川臧线 &amp; 折多山"></a>318川臧线 &amp; 折多山</h3><p>过了泸定桥，海拔就开始上升了，立马就可以感受蓝天，白云带来的视觉震撼。318川藏线一直是盘山公路，道路两边 蓝天白云，雪山云海，草原牛羊 非常有旅行的感觉。由于刚开始没见过市面比较激动，看到都直接录像了，这里没有照片。</p><p>折多山是第一个让你感觉缺氧的地方，一次多爬几个台阶就能感受到心脏跳动的咚咚声。也是高原风貌最明显的地方，紫外线很强，风大，到处是经幡。<br><img src="/photo_2019/zheduoshan.jpeg" alt=""></p><h3 id="新都桥"><a href="#新都桥" class="headerlink" title="新都桥"></a>新都桥</h3><p>新都桥虽然是摄影天堂，但说的是秋天的新都桥，现在没啥看的。而且第一天开始缺氧，已经不敢剧烈运动，也没有去看贡嘎雪山日落。非常棒的是，草原的酒店开窗可以看到远处的山和近处的草原，很惬意。</p><p>注意的是，晚上不要洗澡。特别容易感冒。</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="天路十八弯"><a href="#天路十八弯" class="headerlink" title="天路十八弯"></a>天路十八弯</h3><p>第二天会走过天路十八弯，是一段特别绕的盘山公路，上山后可在观景台观看盘山公路。过了这里入眼就是大片大片的草原和云海，风景不错。</p><p>注意：高海拔爬升导游不让睡觉，睡觉会导致呼吸和心跳变慢，一醒来一般会突然高反。</p><h3 id="卡子拉山"><a href="#卡子拉山" class="headerlink" title="卡子拉山"></a>卡子拉山</h3><p>卡子拉山海拔4716，但是GPS实际显示4400左右。山顶是一大片平原，到天边才是云海和山峰。</p><h3 id="世界高城"><a href="#世界高城" class="headerlink" title="世界高城"></a>世界高城</h3><p>只是一个牌楼一样的标志性建筑，打个卡就行。</p><h3 id="稻城亚丁地质公园"><a href="#稻城亚丁地质公园" class="headerlink" title="稻城亚丁地质公园"></a>稻城亚丁地质公园</h3><p>一个湖泊，一条河，风景虽好，但是感觉在这里风景都挺好，这已经只是平均水平了。继续向稻城亚丁前进。</p><p><img src="/photo_2019/daochengdizhi.jpeg" alt=""></p><h3 id="白塔"><a href="#白塔" class="headerlink" title="白塔"></a>白塔</h3><p>稻城的一处佛教景点，可以打个卡。过了这里会有医疗站的人上车宣传科普，顺便卖氧气瓶，68一瓶，这个大概每人2-3个就行。想舒服的旅行，这个氧气瓶得准备充足。（不过不要多买，买多了只能扔掉，，，这个是易燃易爆物，下了高原，一点用没有，只能扔掉，心疼我的3瓶氧气，）</p><p><img src="/photo_2019/baita.jpeg" alt=""></p><h2 id="第三天-稻城亚丁"><a href="#第三天-稻城亚丁" class="headerlink" title="第三天 稻城亚丁"></a>第三天 稻城亚丁</h2><p>早上睡着睡着被脑壳疼醒，一看表才4点，不知道是不是早晨房间里氧气更少了的缘故。一测血氧，75%。快吓尿了，赶紧来几口氧气。但是已经高反后再吸氧，脑壳还是疼，来了一片散利痛，瞬间感觉活过来了，彷佛一口气可以上五楼。睡不着继续翻了下资料，试了下后发现其实只要调整呼吸，主动增压呼吸就可以1分钟内将血氧提升到96%，瞬间有了信心。</p><h3 id="云海"><a href="#云海" class="headerlink" title="云海"></a>云海</h3><p>景区进去后还得坐一个小时的大巴，大巴一路上都是在云海中穿行。风吹云海见雪山，到这已经觉得不虚此行了。<br><img src="/photo_2019/yunhai.jpeg" alt=""></p><h3 id="冲古寺"><a href="#冲古寺" class="headerlink" title="冲古寺"></a>冲古寺</h3><p>背靠雪山的一座寺庙，由于下午5.30必须下山，只是进去看了一眼就离开了。这里是大巴下车后换乘小观光车的地方，也是长线和短线的分离点，建议玩长线，不要在这里耽误时间。</p><p><img src="/photo_2019/chonggusi.jpeg" alt=""></p><p>旁边是两山夹着的草原和河，更有远处的雪山和云海。河水很清，等走到最后就会发现是从最远处的雪山上流下来的。</p><p><img src="/photo_2019/heliu.jpeg" alt=""></p><h3 id="洛绒牛场"><a href="#洛绒牛场" class="headerlink" title="洛绒牛场"></a>洛绒牛场</h3><p>观光车沿途可以看到远处的雪山（其实貌似是石灰山还是啥）和草原。下车的地方是洛绒牛场，又又是一片大草原。</p><p><img src="/photo_2019/niuchang.jpeg" alt=""><br>远处的雪山<br><img src="/photo_2019/xueshanss.jpeg" alt=""></p><h3 id="雪山"><a href="#雪山" class="headerlink" title="雪山"></a>雪山</h3><p>其实看起来并不是雪山，是白色沙子和水在流。<br><img src="/photo_2019/xueshans.jpeg" alt=""></p><h3 id="牛奶海"><a href="#牛奶海" class="headerlink" title="牛奶海"></a>牛奶海</h3><p>到达牛奶海和五色海分岔路口时，可以先去牛奶海，再从牛奶海去五色海。如果先去五色海，将要爬一段特别陡的山。那地方只要爬山，基本走60步就要休息，缓坡反而无所谓。所以不想太难受的话，先去牛奶海。</p><p>可惜的是本来好好的天气，上山之后突然阴天了，还下起了雨。<br><img src="/photo_2019/niunaihai.jpeg" alt=""></p><h3 id="五色海"><a href="#五色海" class="headerlink" title="五色海"></a>五色海</h3><p>终点站。由于下雨，并没有多么惊艳。但是稻城亚丁每一处都是风景。<br><img src="/photo_2019/final_sea.jpeg" alt=""></p><p>5点30小观光车停止运行，所以14.30必须从这里离开，不然可能得搭车回去了。</p><h3 id="蓝天-彩虹"><a href="#蓝天-彩虹" class="headerlink" title="蓝天 彩虹"></a>蓝天 彩虹</h3><p>回来途中，天却突然晴了，还出来了彩虹。。。第一次坐景区大巴车副驾驶，感受了一把秋名山漂车的紧张刺激，生怕大巴车拐这几十个180度弯时翻车了。。。</p><p>格桑花和彩虹<br><img src="/photo_2019/caihong.jpeg" alt=""></p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>早上去一个藏民家去参观。下车藏民会送哈达并给你说扎西德勒，你必须回个扎西德勒朔来打招呼。酥油茶和糌粑并不是很好吃，一个很咸，一个没有一点味道。然后就是文化的讲解和民族手工艺品的展览。</p><p>出来又去了一个经堂，也是免费参观。外面的景色不错，刚淋过雨的格桑花，非常好看。<br><img src="/photo_2019/gesanghua.jpeg" alt=""></p><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><p>半天到成都，一直在睡觉。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>诗和远方还是要有的，远方终将成为脚下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想去稻城亚丁的想法在TODO 清单里躺了很久，这次终于安排上。和最爱的人来到了这个‘蓝色星球上的最后一片净土’，看到了最美的风景，当然也感受到了高海拔缺氧带来的痛苦。&lt;/p&gt;
&lt;p&gt;读完本篇将知道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一视角的稻城亚丁跟团游行程&lt;/li&gt;
&lt;li&gt;如何安排行程，行程前准备，旅行中看啥美景，吃啥美食，以及可能的消费&lt;/li&gt;
&lt;li&gt;如何避免被坑，哪些地方有坑&lt;/li&gt;
&lt;li&gt;如何第一次跟团游&lt;/li&gt;
&lt;li&gt;如何减弱高原反应（的痛苦）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="游记" scheme="http://www.javabin.cn/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="生活" scheme="http://www.javabin.cn/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>【第三方库分享】使用invoke简单执行系统任务</title>
    <link href="http://www.javabin.cn/2019/invoke_pypi.html"/>
    <id>http://www.javabin.cn/2019/invoke_pypi.html</id>
    <published>2019-09-03T18:25:24.000Z</published>
    <updated>2024-03-11T14:49:03.604Z</updated>
    
    <content type="html"><![CDATA[<p>使用invoke python库简单执行系统任务，很方便。<br><a id="more"></a></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>invoke是一个python第三方库，和fabric类似。可以方便的执行系统任务。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>sudo pip install invoke</code></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>被invoke.task装饰的方法，均可使用inv 直接调用<br>编写<code>tasks.py</code>文件，注意名称必须为<code>tasks.py</code></p><pre><code class="python">    # coding: utf-8    &quot;&quot;&quot;    test invoke    # 在命令行执行下面命令即可    inv -l # 查看所有支持的操作    inv func    inv add 1 2    inv listdir --path=/    &quot;&quot;&quot;    import invoke    @invoke.task    def func():        &quot;&quot;&quot;        test task        :return:        &quot;&quot;&quot;        print 123    @invoke.task    def add(a, b):  # pylint: disable=invalid-name        &quot;&quot;&quot;        add        :param a:        :param b:        :return:        &quot;&quot;&quot;        print int(a) + int(b)    @invoke.task    def listdir(path):        invoke.run(&quot;ls {}&quot;.format(path))</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用invoke python库简单执行系统任务，很方便。&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="python" scheme="http://www.javabin.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>简简单单，明明白白得使用git</title>
    <link href="http://www.javabin.cn/2019/git_command.html"/>
    <id>http://www.javabin.cn/2019/git_command.html</id>
    <published>2019-09-03T16:25:24.000Z</published>
    <updated>2024-03-11T14:49:03.597Z</updated>
    
    <content type="html"><![CDATA[<p>简简单单，明明白白得使用git</p><p>git基本概念和常用命令<br><a id="more"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>工作区<code>在git文件夹里，但是还没有加入版本控制</code></li><li>暂存区<code>已加入版本控制</code></li><li>对象区<code>已提交到本地仓库</code></li><li>远程服务<code>已提交到云端</code></li></ul><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li>克隆分支到本地 <code>git clone xxxx.git</code> </li><li>查看当前分支<code>git branch</code></li><li>查看所有分支<code>git branch -a</code></li><li>创建分支<code>git branch dev</code></li><li>切换分支<code>git checkout dev</code></li><li>查看文件状态<code>git status</code></li><li>添加文件到版本控制<code>git add 1.txt</code></li><li>提交文件到本地仓库<code>git commit -m &quot;fix encode error&quot;</code></li><li>改变基线，从master同步过来<code>git rebase master</code></li><li>解决变基冲突，直接使用远程代码<code>git rebase --skip</code></li><li>解决变基冲突，手动解决冲突后<code>git add .</code>, <code>git rebase --continue</code></li><li>解决变基冲突，撤销变基<code>git rebase --abort</code></li><li>提交文件到远程仓库<code>git push</code></li><li>查看仓库改动<code>git fetch</code></li><li>更新远程分支变动到本地<code>git pull</code></li><li>查看提交日志<code>git log</code></li><li>同步其他分支的变更<code>git merge master</code></li><li>撤销git add <code>git rm --cached 1.txt</code>或者<code>git reset 1.txt</code></li><li>回滚到某次提交<code>git reset --hard commit_id</code></li></ul><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>rebase不能在自由分支执行，就是只在自己分支rebase</li><li>reset前注意备份</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简简单单，明明白白得使用git&lt;/p&gt;
&lt;p&gt;git基本概念和常用命令&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="git" scheme="http://www.javabin.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>我的书单[2019]</title>
    <link href="http://www.javabin.cn/2019/book_list.html"/>
    <id>http://www.javabin.cn/2019/book_list.html</id>
    <published>2019-08-23T15:10:54.000Z</published>
    <updated>2024-03-11T14:49:03.592Z</updated>
    
    <content type="html"><![CDATA[<p>我的2019书单<br><a id="more"></a></p><h2 id="Java并发编程的艺术"><a href="#Java并发编程的艺术" class="headerlink" title="Java并发编程的艺术"></a><del>Java并发编程的艺术</del></h2><p>java并发编程相关的多线程，锁优化，虚拟机都有讲到。</p><h2 id="穷爸爸富爸爸"><a href="#穷爸爸富爸爸" class="headerlink" title="穷爸爸富爸爸"></a><del>穷爸爸富爸爸</del></h2><p>讲财商的，不想一辈子搬砖的话可以了解一下。</p><h2 id="卡耐基沟通与人际关系"><a href="#卡耐基沟通与人际关系" class="headerlink" title="卡耐基沟通与人际关系"></a><del>卡耐基沟通与人际关系</del></h2><p>卡耐基系列，讲如何更好得与别人相处。</p><h2 id="重来2"><a href="#重来2" class="headerlink" title="重来2"></a>重来2</h2><p>关于远程工作</p><h2 id="暗时间"><a href="#暗时间" class="headerlink" title="暗时间"></a><del>暗时间</del></h2><p>程序员总结的一些知识，心理学，学习，编程</p><h2 id="程序员的呐喊"><a href="#程序员的呐喊" class="headerlink" title="程序员的呐喊"></a><del>程序员的呐喊</del></h2><p>程序员的总结，让学习编译原理，操作系统，学习其他语言。学习lisp和EMACS。</p><h2 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a><del>黑客与画家</del></h2><p>关于创业。</p><h2 id="两周自制脚本语言"><a href="#两周自制脚本语言" class="headerlink" title="两周自制脚本语言"></a>两周自制脚本语言</h2><p>编译原理</p><h2 id="代码整洁之道"><a href="#代码整洁之道" class="headerlink" title="代码整洁之道"></a>代码整洁之道</h2><p>保证写的代码易维护</p><h2 id="代码大全"><a href="#代码大全" class="headerlink" title="代码大全"></a>代码大全</h2><p>看了一部分。编写代码中遇到的各种问题的处理方式。</p><h2 id="机器学习实战"><a href="#机器学习实战" class="headerlink" title="机器学习实战"></a>机器学习实战</h2><p>机器学习相关的算法的Python实现</p><h2 id="大型网站技术架构"><a href="#大型网站技术架构" class="headerlink" title="大型网站技术架构"></a><del>大型网站技术架构</del></h2><p>标题即内容。</p><h2 id="python-cookbook"><a href="#python-cookbook" class="headerlink" title="python cookbook"></a><del>python cookbook</del></h2><p>Python必看。</p><h2 id="流畅的python"><a href="#流畅的python" class="headerlink" title="流畅的python"></a><del>流畅的python</del></h2><p>Python必看</p><h2 id="金字塔原理"><a href="#金字塔原理" class="headerlink" title="金字塔原理"></a><del>金字塔原理</del></h2><p>讲 写文章的逻辑，说话的逻辑。</p><h2 id="tensorflow-实战google深度学习框架"><a href="#tensorflow-实战google深度学习框架" class="headerlink" title="tensorflow 实战google深度学习框架"></a><del>tensorflow 实战google深度学习框架</del></h2><p>学习tensorflow非常棒的一本书，从是什么到为什么，再到怎么做。又避开了部分冗长的数学证明。初学者可以一边看一边实战，入门很棒。</p><h2 id="重构-改善既有代码的设计"><a href="#重构-改善既有代码的设计" class="headerlink" title="重构 :改善既有代码的设计"></a>重构 :改善既有代码的设计</h2><p>如何对现有系统进行重构，接手他人项目的话，这本书很有帮助。</p><h2 id="大型网站技术架构-核心原理与案例分析"><a href="#大型网站技术架构-核心原理与案例分析" class="headerlink" title="大型网站技术架构:核心原理与案例分析"></a><del>大型网站技术架构:核心原理与案例分析</del></h2><p>标题即内容</p><h2 id="系统之美"><a href="#系统之美" class="headerlink" title="系统之美"></a>系统之美</h2><p>未看</p><h2 id="HeadFirst设计模式"><a href="#HeadFirst设计模式" class="headerlink" title="HeadFirst设计模式"></a>HeadFirst设计模式</h2><p>只看了几个常用的，书太厚。</p><h2 id="编程珠玑"><a href="#编程珠玑" class="headerlink" title="编程珠玑"></a>编程珠玑</h2><p>算法和数据结构之美</p><h2 id="软技能-代码之外的生存指南"><a href="#软技能-代码之外的生存指南" class="headerlink" title="软技能: 代码之外的生存指南"></a><del>软技能: 代码之外的生存指南</del></h2><p>程序员必读，世界观修正</p><h2 id="程序员修炼之道-从小工到专家"><a href="#程序员修炼之道-从小工到专家" class="headerlink" title="程序员修炼之道:从小工到专家"></a>程序员修炼之道:从小工到专家</h2><p>未看</p><h2 id="计算机程序的构造和解释"><a href="#计算机程序的构造和解释" class="headerlink" title="计算机程序的构造和解释"></a>计算机程序的构造和解释</h2><p>未看</p><h2 id="人月神话"><a href="#人月神话" class="headerlink" title="人月神话"></a>人月神话</h2><p>软件管理相关的。</p><h2 id="时间的形状-相对论史话"><a href="#时间的形状-相对论史话" class="headerlink" title="时间的形状-相对论史话"></a><del>时间的形状-相对论史话</del></h2><p>关于经典物理学和现代物理学发展的。从低速到高速，从宇宙到量子，从非惯性系到非惯性系，从经典物理学到量子物理学，两个字 神奇。</p><h2 id="人性的弱点"><a href="#人性的弱点" class="headerlink" title="人性的弱点"></a><del>人性的弱点</del></h2><p>卡耐基的书，讲与人交往的，包括与朋友，父母，孩子等。</p><h2 id="算法第四版"><a href="#算法第四版" class="headerlink" title="算法第四版"></a>算法第四版</h2><p>只看了红黑树之前</p><h2 id="算法的java实现"><a href="#算法的java实现" class="headerlink" title="算法的java实现"></a>算法的java实现</h2><p>只看了红黑树之前</p><h2 id="三体1-2-3"><a href="#三体1-2-3" class="headerlink" title="三体1/2/3"></a><del>三体1/2/3</del></h2><p>脑洞大开。科幻巨著。</p><h2 id="Rabbitmq实战指南"><a href="#Rabbitmq实战指南" class="headerlink" title="Rabbitmq实战指南"></a><del>Rabbitmq实战指南</del></h2><p>一书搞懂rabbitmq</p><h2 id="Linux-shell命令和编辑器？"><a href="#Linux-shell命令和编辑器？" class="headerlink" title="Linux shell命令和编辑器？"></a><del>Linux shell命令和编辑器？</del></h2><p>刚看完，貌似叫这个名字。linux命令一锅炖了，顺便讲了自带的几种编辑器的用法。</p><h2 id="erlang程序设计"><a href="#erlang程序设计" class="headerlink" title="erlang程序设计"></a>erlang程序设计</h2><p>打算看。以并发编程的模式思考问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的2019书单&lt;br&gt;
    
    </summary>
    
    
      <category term="书单" scheme="http://www.javabin.cn/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="看书" scheme="http://www.javabin.cn/tags/%E7%9C%8B%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>一次Python电话面试经验分享[GET offer]</title>
    <link href="http://www.javabin.cn/2019/iv_cd_01.html"/>
    <id>http://www.javabin.cn/2019/iv_cd_01.html</id>
    <published>2019-08-23T15:10:54.000Z</published>
    <updated>2024-03-11T14:49:03.604Z</updated>
    
    <content type="html"><![CDATA[<p>一次电话面试经验分享。<br><a id="more"></a></p><p>貌似招精通elasticsearch，Python的，所以刚开始都是问elasticsearch相关的问题。过程很顺利，一次远程电面直接获得offer，涨薪约40%+。</p><h2 id="面试问题："><a href="#面试问题：" class="headerlink" title="面试问题："></a>面试问题：</h2><ul><li>自我介绍</li><li>elasticsearch在你的项目中如何使用。</li><li>说一下elasticsearch如何安装部署?配置？</li><li>elasticsearch压力测试如何做的？</li><li>elasticsearch分片</li><li>elasticsearch分布式</li><li>存储过程用过吗？你是在什么情况下使用的？</li><li>sql优化你一般是如何做的？</li><li>redis在你的项目里怎么使用的？</li><li>mongo在你的项目里怎么使用的？</li><li>结巴分词在elasticsearch中使用？</li><li>分词的配置如何做的？</li><li>你的项目的git管理如何管理的？</li><li>数据库表设计如何做?</li><li>一个项目你一般会做哪些设计？</li><li>API接口一般如何测试？</li><li>你一般是如何出具API文档的？</li><li>设计模式都会什么？说下单例模式？</li><li>项目使用的Python3还是2？为什么？</li><li>你最近看了哪些书？</li><li>听说过持续集成吗？jekins如何使用？</li><li>Python静态代码检查你们项目是怎么做的?</li><li>自动化编译部署呢？</li><li>编程语言还会什么？是自学还是学校学习的？</li><li>java项目中常用的框架说一下？</li><li>用过mybatis吗？</li><li>说下ssh和ssm?</li><li>除了django外还用过其他框架吗？flask用过吗？</li><li>Mysql和Pgsql差异?</li></ul><h2 id="待加强"><a href="#待加强" class="headerlink" title="待加强"></a>待加强</h2><ul><li>了解elasticsearch分布式相关的原理</li><li>CI/CD，jekins</li><li>近期书单整理（面试当天刚好看完了《人性的弱点》，面试官不知道是什么，很懵逼）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次电话面试经验分享。&lt;br&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="面试" scheme="http://www.javabin.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>倒排索引的原理</title>
    <link href="http://www.javabin.cn/2019/r_index.html"/>
    <id>http://www.javabin.cn/2019/r_index.html</id>
    <published>2019-08-09T15:01:21.000Z</published>
    <updated>2024-03-11T14:49:03.610Z</updated>
    
    <content type="html"><![CDATA[<ul><li>倒排索引是什么</li><li>区别</li><li>索引的数据结构</li></ul><a id="more"></a><h2 id="倒排索引是什么"><a href="#倒排索引是什么" class="headerlink" title="倒排索引是什么"></a>倒排索引是什么</h2><p>通过值来查找记录。通过建立词到文档的映射关系，在查询词时，可以直接查询出包含当前词的文档。<br>比如我们有几本书，为了能检索方便，我们通过分词将所有书里的词语提取出来，然后建立词语到书文件之间的对应关系。</p><pre><code>词语         书孙悟空    《西游记》武松         《水浒传》师父         《西游记》,《水浒传》,《红楼梦》...</code></pre><p>这就是一个简单的倒排索引。搜索时，如果搜索 孙悟空，就可以查找到书《西游记》，而搜 师父，就可以查找到书《西游记》,《水浒传》,《红楼梦》。</p><p>带词频的倒排索引（数字为虚构）。即建立倒排索引时记录当前词在文档中出现的次数，然后搜索结果即可以根据频率进行排序展示，使和搜索词相关的文档靠前排列。</p><pre><code>词语        文件,词频孙悟空     (《西游记》,1111)武松         ( 《水浒传》,111)师父         (《西游记》,111),(《水浒传》,33),(《红楼梦》,12）</code></pre><p>如果现在继续搜 师父，我们得到的结果就是1.《西游记》 2.《水浒传》3.《红楼梦》</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>倒排索引。从词查文档。</p><p>正向索引。从文档查词。即要查询一个词在哪个文档里，必须遍历索引库里的每个文档才行。</p><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>当索引的单词数量太多时，如何才能快速定位单词对应的文档呢？</p><h3 id="1-hash拉链法-（数组-链表实现的hash表）"><a href="#1-hash拉链法-（数组-链表实现的hash表）" class="headerlink" title="1.hash拉链法 （数组+链表实现的hash表）"></a>1.hash拉链法 （数组+链表实现的hash表）</h3><p>通过将单词作为hash表的Key，来实现对倒排索引的快速查询。通过拉链法来实现hash表哈希冲突。</p><p>拉链法，hash表解决冲突的一种实现方式，java中的hashmap就是如此实现的，即使用数组+链表方式实现hash表。先以初始容量生成一个初始容量大小的数组。插入元素时通过 输入数据长度和 数组长度的取余来确定数据插入的位置。如果插入时hash表的的容量已经达到负载因子设置的容量，则进行数组扩充，将数组扩大一倍后重新整理数据。如果插入时发生冲突，则将数据插入到当前数组位置关联的链表上。如果没有冲突，直接插入当前数组位置的链表的第一个节点上。</p><p><img src="/photo_2019/hash_la.png" alt=""></p><p>绿色是数组，黄色是链表。</p><p>插入时，插入数组下标=len(word) % 3。比如 孙悟空 这个词长度为  3被插入下标为0的位置。武松 这个词长度为2，被插入下标为2的位置。</p><p>插入时，如果发生冲突的话，插入链表里。比如师父，长度为2。但是下标为2的位置已经被占用了，那么插入当前下标关联的链表里。</p><p>查询时，查询在数组中的下标=len(word) % 3。比如 孙悟空 这个词长度为 3，则他在下标为0的位置。如果数组位置不是要查询的词，遍历链表进行查询，如查询 师父，下标为2的位置不是要查询的词，则遍历链表，直到查找到key 师父。</p><h3 id="2-字典树"><a href="#2-字典树" class="headerlink" title="2.字典树"></a>2.字典树</h3><p>字典树是根据字符串的前缀构成的树结构。查询时只需用查询词的前缀依次比较到词末，即可查询到对应的单词，比较次数最多为单词的长度。</p><p><img src="/photo_2019/trie.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;倒排索引是什么&lt;/li&gt;
&lt;li&gt;区别&lt;/li&gt;
&lt;li&gt;索引的数据结构&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="全文检索" scheme="http://www.javabin.cn/tags/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/"/>
    
      <category term="倒排索引" scheme="http://www.javabin.cn/tags/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式之零宽断言</title>
    <link href="http://www.javabin.cn/2019/re_zero.html"/>
    <id>http://www.javabin.cn/2019/re_zero.html</id>
    <published>2019-08-06T16:57:15.000Z</published>
    <updated>2024-03-11T14:49:03.612Z</updated>
    
    <content type="html"><![CDATA[<p>如何使用正则表达式中的零宽断言</p><a id="more"></a><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>一种正则表达式的匹配方式。不占用字符宽度，不匹配任何字符，只是一种条件。</p><p>比如，</p><pre><code>a=&quot;123,312312,dawdqwd,123123123,1231231,dasd121d,a12313,&quot;</code></pre><p>要取出两个逗号间是纯数字的内容，如果我们使用以下方式，就会发现匹配的少了好多项目，由于逗号被匹配并消耗掉，导致前一个匹配到逗号后，后一个无法匹配到逗号。</p><pre><code>In [67]: re.compile(r&quot;,(\d+?),&quot;).findall(a)Out[67]: [&#39;312312&#39;, &#39;123123123&#39;]</code></pre><p>如果使用零宽断言匹配，前后有逗号，中间是数字的项目。</p><pre><code>In [65]: re.compile(r&quot;(?&lt;=,)\d+?(?=,)&quot;).findall(a)Out[65]: [&#39;312312&#39;, &#39;123123123&#39;, &#39;1231231&#39;]</code></pre><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="正预测先行断言"><a href="#正预测先行断言" class="headerlink" title="正预测先行断言"></a>正预测先行断言</h3><p>此位置后面必须可以匹配exp。(?=exp)</p><p>匹配后面是小写字母的数字</p><pre><code>b=&quot;123A456a789c101112C1234DSDSDzzz1111%%%&quot;In [131]: re.compile(r&quot;\d+?(?=[a-z]+?)&quot;).findall(b)Out[131]: [&#39;456&#39;, &#39;789&#39;]</code></pre><h3 id="负预测先行断言"><a href="#负预测先行断言" class="headerlink" title="负预测先行断言"></a>负预测先行断言</h3><p>此位置后面不能匹配exp。(?!exp)</p><p>匹配后面是小写字母的数字（后面不是数字，不是大写字母，不是特殊符号% 的数字）</p><pre><code>In [152]: re.compile(r&quot;\d+(?![A-Z0-9%])&quot;).findall(b)Out[152]: [&#39;456&#39;, &#39;789&#39;]</code></pre><h3 id="正后顾后发断言"><a href="#正后顾后发断言" class="headerlink" title="正后顾后发断言"></a>正后顾后发断言</h3><p>此位置前面必须匹配exp。(?&lt;=exp)</p><p>匹配前面是数字的大写字母</p><pre><code>In [153]: re.compile(r&quot;(?&lt;=\d)[A-Z]+&quot;).findall(b)Out[153]: [&#39;A&#39;, &#39;C&#39;, &#39;DSDSD&#39;]</code></pre><h3 id="负后顾后发断言"><a href="#负后顾后发断言" class="headerlink" title="负后顾后发断言"></a>负后顾后发断言</h3><p>此位置前面不能匹配exp。(?&lt;!exp)</p><p>匹配前面不是数字的小写字母</p><pre><code>In [155]: re.compile(r&quot;(?&lt;!\d)[a-z]+&quot;).findall(b)Out[155]: [&#39;zzz&#39;]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何使用正则表达式中的零宽断言&lt;/p&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://www.javabin.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="linux" scheme="http://www.javabin.cn/tags/linux/"/>
    
      <category term="正则表达式" scheme="http://www.javabin.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
